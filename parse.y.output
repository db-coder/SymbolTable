[[parse.y (info)] Line 349: 
Production Rules
(rule precedences determined from %prec or 1st terminal between parentheses):
1: translation_unit ->  struct_specifier
2: translation_unit ->  function_definition
3: translation_unit ->  translation_unit function_definition
4: translation_unit ->  translation_unit struct_specifier
5: struct_specifier (STRUCT) ->  #0001 STRUCT IDENTIFIER '{' declaration_list '}' ';'
6: #0001 ->  <empty>
7: function_definition ->  #0002 type_specifier #0003 fun_declarator #0004 compound_statement
8: #0002 ->  <empty>
9: #0003 ->  <empty>
10: #0004 ->  <empty>
11: type_specifier (VOID) ->  VOID
12: type_specifier (INT) ->  INT
13: type_specifier (FLOAT) ->  FLOAT
14: type_specifier (STRUCT) ->  STRUCT IDENTIFIER
15: fun_declarator (IDENTIFIER) ->  IDENTIFIER '(' parameter_list ')'
16: fun_declarator (IDENTIFIER) ->  IDENTIFIER '(' ')'
17: fun_declarator ('*') ->  '*' fun_declarator
18: parameter_list ->  parameter_declaration
19: parameter_list (',') ->  parameter_list ',' parameter_declaration
20: parameter_declaration ->  type_specifier declarator
21: declarator (IDENTIFIER) ->  IDENTIFIER
22: declarator ('[') ->  declarator '[' primary_expression ']'
23: declarator ('*') ->  '*' declarator
24: primary_expression ->  l_expression
25: primary_expression (INT_CONSTANT) ->  INT_CONSTANT
26: primary_expression (FLOAT_CONSTANT) ->  FLOAT_CONSTANT
27: primary_expression (STRING_LITERAL) ->  STRING_LITERAL
28: primary_expression ('(') ->  '(' expression ')'
29: compound_statement ('{') ->  '{' '}'
30: compound_statement ('{') ->  '{' statement_list '}'
31: compound_statement ('{') ->  '{' declaration_list statement_list '}'
32: statement_list ->  statement
33: statement_list ->  statement_list statement
34: statement ('{') ->  '{' statement_list '}'
35: statement ->  selection_statement
36: statement ->  iteration_statement
37: statement ->  assignment_statement
38: statement (RETURN) ->  RETURN expression ';'
39: assignment_statement (';') ->  ';'
40: assignment_statement (';') ->  expression ';'
41: expression ->  logical_or_expression
42: expression ('=') ->  l_expression '=' expression
43: logical_or_expression ->  logical_and_expression
44: logical_or_expression (OR_OP) ->  logical_or_expression OR_OP logical_and_expression
45: logical_and_expression ->  equality_expression
46: logical_and_expression (AND_OP) ->  logical_and_expression AND_OP equality_expression
47: equality_expression ->  relational_expression
48: equality_expression (EQ_OP) ->  equality_expression EQ_OP relational_expression
49: equality_expression (NE_OP) ->  equality_expression NE_OP relational_expression
50: relational_expression ->  additive_expression
51: relational_expression ('<') ->  relational_expression '<' additive_expression
52: relational_expression ('>') ->  relational_expression '>' additive_expression
53: relational_expression (LE_OP) ->  relational_expression LE_OP additive_expression
54: relational_expression (GE_OP) ->  relational_expression GE_OP additive_expression
55: additive_expression ->  multiplicative_expression
56: additive_expression ('+') ->  additive_expression '+' multiplicative_expression
57: additive_expression ('-') ->  additive_expression '-' multiplicative_expression
58: multiplicative_expression ->  unary_expression
59: multiplicative_expression ('*') ->  multiplicative_expression '*' unary_expression
60: multiplicative_expression ('/') ->  multiplicative_expression '/' unary_expression
61: unary_expression ->  postfix_expression
62: unary_expression ->  unary_operator postfix_expression
63: postfix_expression ->  primary_expression
64: postfix_expression (IDENTIFIER) ->  IDENTIFIER '(' ')'
65: postfix_expression (IDENTIFIER) ->  IDENTIFIER '(' expression_list ')'
66: postfix_expression ('[') ->  postfix_expression '[' expression ']'
67: postfix_expression ('.') ->  postfix_expression '.' IDENTIFIER
68: postfix_expression (PTR_OP) ->  postfix_expression PTR_OP IDENTIFIER
69: postfix_expression (INC_OP) ->  postfix_expression INC_OP
70: l_expression (IDENTIFIER) ->  IDENTIFIER
71: l_expression ('[') ->  l_expression '[' expression ']'
72: l_expression ('*') ->  '*' l_expression
73: l_expression ('.') ->  l_expression '.' IDENTIFIER
74: l_expression (PTR_OP) ->  l_expression PTR_OP IDENTIFIER
75: l_expression ('(') ->  '(' l_expression ')'
76: expression_list ->  expression
77: expression_list (',') ->  expression_list ',' expression
78: unary_operator ('-') ->  '-'
79: unary_operator ('!') ->  '!'
80: unary_operator ('&') ->  '&'
81: unary_operator ('*') ->  '*'
82: selection_statement (IF) ->  IF '(' expression ')' statement ELSE statement
83: iteration_statement (WHILE) ->  WHILE '(' expression ')' statement
84: iteration_statement (FOR) ->  FOR '(' expression ';' expression ';' expression ')' statement
85: declaration_list ->  declaration
86: declaration_list ->  declaration_list declaration
87: declaration (';') ->  type_specifier declarator_list ';'
88: declarator_list ->  declarator
89: declarator_list (',') ->  declarator_list ',' declarator
90: translation_unit_$ ->  translation_unit

[[parse.y (info)] 
Symbolic Terminal tokens:
       error
       EOF
   257: VOID
   258: INT
   259: FLOAT
   260: FLOAT_CONSTANT
   261: INT_CONSTANT
   262: AND_OP
   263: OR_OP
   264: EQ_OP
   265: NE_OP
   266: GE_OP
   267: LE_OP
   268: STRING_LITERAL
   269: IF
   270: ELSE
   271: WHILE
   272: FOR
   273: RETURN
   274: STRUCT
   275: IDENTIFIER
   276: INC_OP
   277: PTR_OP
   287: constant_expression
   123: '{'
   125: '}'
    59: ';'
    40: '('
    41: ')'
    42: '*'
    44: ','
    91: '['
    93: ']'
    61: '='
    60: '<'
    62: '>'
    43: '+'
    45: '-'
    47: '/'
    46: '.'
    33: '!'
    38: '&'

[[parse.y (info)] 
FIRST sets:
   translation_unit: { FLOAT VOID INT STRUCT }
   struct_specifier: { STRUCT }
   function_definition: { FLOAT VOID INT STRUCT }
   #0001:    { <e> }
   declaration_list: { FLOAT VOID INT STRUCT }
   type_specifier: { FLOAT VOID INT STRUCT }
   #0002:    { <e> }
   fun_declarator: { IDENTIFIER '*' }
   #0003:    { <e> }
   #0004:    { <e> }
   parameter_list: { FLOAT VOID INT STRUCT }
   parameter_declaration: { FLOAT VOID INT STRUCT }
   declarator: { IDENTIFIER '*' }
   primary_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }
   compound_statement: { '{' }
   statement_list: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }
   statement: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }
   assignment_statement: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER ';' '*' '(' '-' '!' '&' }
   expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   logical_or_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   logical_and_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   equality_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   relational_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   additive_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   multiplicative_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   unary_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   postfix_expression: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }
   l_expression: { IDENTIFIER '*' '(' }
   expression_list: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' '-' '!' '&' }
   unary_operator: { '*' '-' '!' '&' }
   selection_statement: { IF }
   iteration_statement: { WHILE FOR }
   declaration: { FLOAT VOID INT STRUCT }
   declarator_list: { IDENTIFIER '*' }
   translation_unit_$: { FLOAT VOID INT STRUCT }

[[parse.y (info)] 
FOLLOW sets:
   translation_unit: { FLOAT VOID INT STRUCT <EOF> }
   struct_specifier: { FLOAT VOID INT STRUCT <EOF> }
   function_definition: { FLOAT VOID INT STRUCT <EOF> }
   #0001:    { STRUCT }
   declaration_list: { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   type_specifier: { IDENTIFIER '*' }
   #0002:    { FLOAT VOID INT STRUCT }
   fun_declarator: { '{' }
   #0003:    { IDENTIFIER '*' }
   #0004:    { '{' }
   parameter_list: { ')' ',' }
   parameter_declaration: { ')' ',' }
   declarator: { ';' ')' ',' '[' }
   primary_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }
   compound_statement: { FLOAT VOID INT STRUCT <EOF> }
   statement_list: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   statement: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   assignment_statement: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   expression: { ';' ')' ',' ']' }
   logical_or_expression: { OR_OP ';' ')' ',' ']' }
   logical_and_expression: { AND_OP OR_OP ';' ')' ',' ']' }
   equality_expression: { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }
   relational_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }
   additive_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }
   multiplicative_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }
   unary_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }
   postfix_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }
   l_expression: { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }
   expression_list: { ')' ',' }
   unary_operator: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }
   selection_statement: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   iteration_statement: { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   declaration: { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }
   declarator_list: { ';' ',' }
   translation_unit_$: { <EOF> }

[[parse.y (info)] 
Grammar States: 
[[parse.y (info)] 
For each state information like the following is shown for its items:
   0: [P1 1] S -> C  . C   { <EOF> }  0, (1 2 ) 0
which should be read as follows:
   0:          The item's index
   [P1 1]:     The rule (production) number and current dot-position
   S -> C . C: The item (lhs -> Recognized-symbols . symbols-to-recognize)
   { <EOF> }   The item's lookahead (LA) set
   0,          The next state's LA set is not enlarged (1: it is enlarged)
   (1 2)       Item indices of items whose LA sets depend on this item
   0           The next-element (shown below the items) describing the
               action associated with this item (-1 for reducible items)

The Next tables show entries like:
   0: On C to state 5 with (0 )
meaning:
   0:               The Next table's index
   On C to state 5: When C was recognized, continue at state 5
   with (0 )        The item(s) whose dot is shifted at the next state
Indices (like 0:) may be annotated as follows:
   0 (AUTO REMOVED by S/R resolution): On C ...
       in which case a reduction using a production with unspecified
       precedence took priority;
or:
   0 (removed by precedence): On C ...
       in which case a production rule's precedence took priority
Also, reduction item(s) may be listed


State 0:
0: [P90 0] translation_unit_$ ->  . translation_unit   { <EOF> }  0, (1 2 3 4 ) 0
1: [P1 0] translation_unit ->  . struct_specifier   { FLOAT VOID INT STRUCT <EOF> }  0, (5 ) 1
2: [P2 0] translation_unit ->  . function_definition   { FLOAT VOID INT STRUCT <EOF> }  0, (6 ) 2
3: [P3 0] translation_unit ->  . translation_unit function_definition   { FLOAT VOID INT STRUCT <EOF> }  0, (1 2 3 4 ) 0
4: [P4 0] translation_unit ->  . translation_unit struct_specifier   { FLOAT VOID INT STRUCT <EOF> }  0, (1 2 3 4 ) 0
5: [P5 0] struct_specifier ->  . #0001 STRUCT IDENTIFIER '{' declaration_list '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, (7 ) 3
6: [P7 0] function_definition ->  . #0002 type_specifier #0003 fun_declarator #0004 compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (8 ) 4
7: [P6 0] #0001 ->  .   { STRUCT }  1, () -1
8: [P8 0] #0002 ->  .   { FLOAT VOID INT }  1, () -1
  0:   On translation_unit to state 1 with (0 3 4 )
  1:   On struct_specifier to state 2 with (1 )
  2:   On function_definition to state 3 with (2 )
  3:   On #0001 to state 4 with (5 )
  4:   On #0002 to state 5 with (6 )
  Reduce item(s): 7 8 
Solved RR CONFLICT for rules 6 and 8:
	removed { STRUCT } from the LA set of rule 8


State 1:
0: [P90 1] translation_unit_$ -> translation_unit  .   { <EOF> }  1, () -1
1: [P3 1] translation_unit -> translation_unit  . function_definition   { FLOAT VOID INT STRUCT <EOF> }  0, (3 ) 0
2: [P4 1] translation_unit -> translation_unit  . struct_specifier   { FLOAT VOID INT STRUCT <EOF> }  0, (4 ) 1
3: [P7 0] function_definition ->  . #0002 type_specifier #0003 fun_declarator #0004 compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (5 ) 2
4: [P5 0] struct_specifier ->  . #0001 STRUCT IDENTIFIER '{' declaration_list '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, (6 ) 3
5: [P8 0] #0002 ->  .   { FLOAT VOID INT }  1, () -1
6: [P6 0] #0001 ->  .   { STRUCT }  1, () -1
  0:   On function_definition to state 6 with (1 )
  1:   On struct_specifier to state 7 with (2 )
  2:   On #0002 to state 5 with (3 )
  3:   On #0001 to state 4 with (4 )
  Reduce item(s): 5 6 
Solved RR CONFLICT for rules 6 and 8:
	removed { STRUCT } from the LA set of rule 8


State 2:
0: [P1 1] translation_unit -> struct_specifier  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 3:
0: [P2 1] translation_unit -> function_definition  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 4:
0: [P5 1] struct_specifier -> #0001  . STRUCT IDENTIFIER '{' declaration_list '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
  0:   On STRUCT to state 8 with (0 )


State 5:
0: [P7 1] function_definition -> #0002  . type_specifier #0003 fun_declarator #0004 compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (1 2 3 4 ) 0
1: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 1
2: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 2
3: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 3
4: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 4
  0:   On type_specifier to state 9 with (0 )
  1:   On VOID to state 10 with (1 )
  2:   On INT to state 11 with (2 )
  3:   On FLOAT to state 12 with (3 )
  4:   On STRUCT to state 13 with (4 )


State 6:
0: [P3 2] translation_unit -> translation_unit function_definition  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 7:
0: [P4 2] translation_unit -> translation_unit struct_specifier  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 8:
0: [P5 2] struct_specifier -> #0001 STRUCT  . IDENTIFIER '{' declaration_list '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
  0:   On IDENTIFIER to state 14 with (0 )


State 9:
0: [P7 2] function_definition -> #0002 type_specifier  . #0003 fun_declarator #0004 compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (1 ) 0
1: [P9 0] #0003 ->  .   { IDENTIFIER '*' }  1, () -1
  0:   On #0003 to state 15 with (0 )
  Reduce item(s): 1 


State 10:
0: [P11 1] type_specifier -> VOID  .   { IDENTIFIER '*' }  1, () -1
  Reduce item(s): 0 


State 11:
0: [P12 1] type_specifier -> INT  .   { IDENTIFIER '*' }  1, () -1
  Reduce item(s): 0 


State 12:
0: [P13 1] type_specifier -> FLOAT  .   { IDENTIFIER '*' }  1, () -1
  Reduce item(s): 0 


State 13:
0: [P14 1] type_specifier -> STRUCT  . IDENTIFIER   { IDENTIFIER '*' }  0, () 0
  0:   On IDENTIFIER to state 16 with (0 )


State 14:
0: [P5 3] struct_specifier -> #0001 STRUCT IDENTIFIER  . '{' declaration_list '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
  0:   On '{' to state 17 with (0 )


State 15:
0: [P7 3] function_definition -> #0002 type_specifier #0003  . fun_declarator #0004 compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (1 2 3 ) 0
1: [P15 0] fun_declarator ->  . IDENTIFIER '(' parameter_list ')'   { '{' }  0, () 1
2: [P16 0] fun_declarator ->  . IDENTIFIER '(' ')'   { '{' }  0, () 1
3: [P17 0] fun_declarator ->  . '*' fun_declarator   { '{' }  0, () 2
  0:   On fun_declarator to state 18 with (0 )
  1:   On IDENTIFIER to state 19 with (1 2 )
  2:   On '*' to state 20 with (3 )


State 16:
0: [P14 2] type_specifier -> STRUCT IDENTIFIER  .   { IDENTIFIER '*' }  1, () -1
  Reduce item(s): 0 


State 17:
0: [P5 4] struct_specifier -> #0001 STRUCT IDENTIFIER '{'  . declaration_list '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, (1 2 ) 0
1: [P85 0] declaration_list ->  . declaration   { FLOAT VOID INT STRUCT '}' }  0, (3 ) 1
2: [P86 0] declaration_list ->  . declaration_list declaration   { FLOAT VOID INT STRUCT '}' }  0, (1 2 ) 0
3: [P87 0] declaration ->  . type_specifier declarator_list ';'   { FLOAT VOID INT STRUCT '}' }  0, (4 5 6 7 ) 2
4: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 3
5: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 4
6: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 5
7: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 6
  0:   On declaration_list to state 21 with (0 2 )
  1:   On declaration to state 22 with (1 )
  2:   On type_specifier to state 23 with (3 )
  3:   On VOID to state 10 with (4 )
  4:   On INT to state 11 with (5 )
  5:   On FLOAT to state 12 with (6 )
  6:   On STRUCT to state 13 with (7 )


State 18:
0: [P7 4] function_definition -> #0002 type_specifier #0003 fun_declarator  . #0004 compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (1 ) 0
1: [P10 0] #0004 ->  .   { '{' }  1, () -1
  0:   On #0004 to state 24 with (0 )
  Reduce item(s): 1 


State 19:
0: [P15 1] fun_declarator -> IDENTIFIER  . '(' parameter_list ')'   { '{' }  0, () 0
1: [P16 1] fun_declarator -> IDENTIFIER  . '(' ')'   { '{' }  0, () 0
  0:   On '(' to state 25 with (0 1 )


State 20:
0: [P17 1] fun_declarator -> '*'  . fun_declarator   { '{' }  0, (1 2 3 ) 0
1: [P15 0] fun_declarator ->  . IDENTIFIER '(' parameter_list ')'   { '{' }  0, () 1
2: [P16 0] fun_declarator ->  . IDENTIFIER '(' ')'   { '{' }  0, () 1
3: [P17 0] fun_declarator ->  . '*' fun_declarator   { '{' }  0, () 2
  0:   On fun_declarator to state 26 with (0 )
  1:   On IDENTIFIER to state 19 with (1 2 )
  2:   On '*' to state 20 with (3 )


State 21:
0: [P5 5] struct_specifier -> #0001 STRUCT IDENTIFIER '{' declaration_list  . '}' ';'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
1: [P86 1] declaration_list -> declaration_list  . declaration   { FLOAT VOID INT STRUCT '}' }  0, (2 ) 1
2: [P87 0] declaration ->  . type_specifier declarator_list ';'   { FLOAT VOID INT STRUCT '}' }  0, (3 4 5 6 ) 2
3: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 3
4: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 4
5: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 5
6: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 6
  0:   On '}' to state 27 with (0 )
  1:   On declaration to state 28 with (1 )
  2:   On type_specifier to state 23 with (2 )
  3:   On VOID to state 10 with (3 )
  4:   On INT to state 11 with (4 )
  5:   On FLOAT to state 12 with (5 )
  6:   On STRUCT to state 13 with (6 )


State 22:
0: [P85 1] declaration_list -> declaration  .   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 23:
0: [P87 1] declaration -> type_specifier  . declarator_list ';'   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P88 0] declarator_list ->  . declarator   { ';' ',' }  0, (3 4 5 ) 1
2: [P89 0] declarator_list ->  . declarator_list ',' declarator   { ';' ',' }  0, (1 2 ) 0
3: [P21 0] declarator ->  . IDENTIFIER   { ';' ',' '[' }  0, () 2
4: [P22 0] declarator ->  . declarator '[' primary_expression ']'   { ';' ',' '[' }  0, (3 4 5 ) 1
5: [P23 0] declarator ->  . '*' declarator   { ';' ',' '[' }  0, () 3
  0:   On declarator_list to state 29 with (0 2 )
  1:   On declarator to state 30 with (1 4 )
  2:   On IDENTIFIER to state 31 with (3 )
  3:   On '*' to state 32 with (5 )


State 24:
0: [P7 5] function_definition -> #0002 type_specifier #0003 fun_declarator #0004  . compound_statement   { FLOAT VOID INT STRUCT <EOF> }  0, (1 2 3 ) 0
1: [P29 0] compound_statement ->  . '{' '}'   { FLOAT VOID INT STRUCT <EOF> }  0, () 1
2: [P30 0] compound_statement ->  . '{' statement_list '}'   { FLOAT VOID INT STRUCT <EOF> }  0, () 1
3: [P31 0] compound_statement ->  . '{' declaration_list statement_list '}'   { FLOAT VOID INT STRUCT <EOF> }  0, () 1
  0:   On compound_statement to state 33 with (0 )
  1:   On '{' to state 34 with (1 2 3 )


State 25:
0: [P15 2] fun_declarator -> IDENTIFIER '('  . parameter_list ')'   { '{' }  0, (2 3 ) 0
1: [P16 2] fun_declarator -> IDENTIFIER '('  . ')'   { '{' }  0, () 1
2: [P18 0] parameter_list ->  . parameter_declaration   { ')' ',' }  0, (4 ) 2
3: [P19 0] parameter_list ->  . parameter_list ',' parameter_declaration   { ')' ',' }  0, (2 3 ) 0
4: [P20 0] parameter_declaration ->  . type_specifier declarator   { ')' ',' }  0, (5 6 7 8 ) 3
5: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 4
6: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 5
7: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 6
8: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 7
  0:   On parameter_list to state 35 with (0 3 )
  1:   On ')' to state 36 with (1 )
  2:   On parameter_declaration to state 37 with (2 )
  3:   On type_specifier to state 38 with (4 )
  4:   On VOID to state 10 with (5 )
  5:   On INT to state 11 with (6 )
  6:   On FLOAT to state 12 with (7 )
  7:   On STRUCT to state 13 with (8 )


State 26:
0: [P17 2] fun_declarator -> '*' fun_declarator  .   { '{' }  1, () -1
  Reduce item(s): 0 


State 27:
0: [P5 6] struct_specifier -> #0001 STRUCT IDENTIFIER '{' declaration_list '}'  . ';'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
  0:   On ';' to state 39 with (0 )


State 28:
0: [P86 2] declaration_list -> declaration_list declaration  .   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 29:
0: [P87 2] declaration -> type_specifier declarator_list  . ';'   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
1: [P89 1] declarator_list -> declarator_list  . ',' declarator   { ';' ',' }  0, () 1
  0:   On ';' to state 40 with (0 )
  1:   On ',' to state 41 with (1 )


State 30:
0: [P88 1] declarator_list -> declarator  .   { ';' ',' }  1, () -1
1: [P22 1] declarator -> declarator  . '[' primary_expression ']'   { ';' ',' '[' }  0, () 0
  0:   On '[' to state 42 with (1 )
  Reduce item(s): 0 


State 31:
0: [P21 1] declarator -> IDENTIFIER  .   { ';' ')' ',' '[' }  1, () -1
  Reduce item(s): 0 


State 32:
0: [P23 1] declarator -> '*'  . declarator   { ';' ')' ',' '[' }  0, (1 2 3 ) 0
1: [P21 0] declarator ->  . IDENTIFIER   { ';' ')' ',' '[' }  0, () 1
2: [P22 0] declarator ->  . declarator '[' primary_expression ']'   { ';' ')' ',' '[' }  0, (1 2 3 ) 0
3: [P23 0] declarator ->  . '*' declarator   { ';' ')' ',' '[' }  0, () 2
  0:   On declarator to state 43 with (0 2 )
  1:   On IDENTIFIER to state 31 with (1 )
  2:   On '*' to state 32 with (3 )


State 33:
0: [P7 6] function_definition -> #0002 type_specifier #0003 fun_declarator #0004 compound_statement  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 34:
0: [P29 1] compound_statement -> '{'  . '}'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
1: [P30 1] compound_statement -> '{'  . statement_list '}'   { FLOAT VOID INT STRUCT <EOF> }  0, (3 4 ) 1
2: [P31 1] compound_statement -> '{'  . declaration_list statement_list '}'   { FLOAT VOID INT STRUCT <EOF> }  0, (5 6 ) 2
3: [P32 0] statement_list ->  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 8 9 10 11 ) 3
4: [P33 0] statement_list ->  . statement_list statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (3 4 ) 1
5: [P85 0] declaration_list ->  . declaration   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }  0, (12 ) 4
6: [P86 0] declaration_list ->  . declaration_list declaration   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }  0, (5 6 ) 2
7: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 5
8: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (13 ) 6
9: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (14 15 ) 7
10: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (16 17 ) 8
11: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
12: [P87 0] declaration ->  . type_specifier declarator_list ';'   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }  0, (18 19 20 21 ) 10
13: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 11
14: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 12
15: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 13
16: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 14
17: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (22 23 ) 15
18: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 16
19: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 17
20: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 18
21: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 19
22: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (24 25 ) 20
23: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (26 27 28 29 30 31 ) 21
24: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (32 33 ) 22
25: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (24 25 ) 20
26: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 23
27: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (26 27 28 29 30 31 ) 21
28: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 24
29: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (26 27 28 29 30 31 ) 21
30: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (26 27 28 29 30 31 ) 21
31: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 25
32: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (34 35 36 ) 26
33: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (32 33 ) 22
34: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (37 38 39 40 41 ) 27
35: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (34 35 36 ) 26
36: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (34 35 36 ) 26
37: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (42 43 44 ) 28
38: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (37 38 39 40 41 ) 27
39: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (37 38 39 40 41 ) 27
40: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (37 38 39 40 41 ) 27
41: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (37 38 39 40 41 ) 27
42: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (45 46 47 ) 29
43: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (42 43 44 ) 28
44: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (42 43 44 ) 28
45: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (48 49 ) 30
46: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (45 46 47 ) 29
47: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (45 46 47 ) 29
48: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 55 56 ) 31
49: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (57 58 59 60 ) 32
50: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (61 62 63 64 65 ) 33
51: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 23
52: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 23
53: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 55 56 ) 31
54: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 55 56 ) 31
55: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 55 56 ) 31
56: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 55 56 ) 31
57: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 34
58: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 35
59: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 36
60: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 24
61: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (26 27 28 29 30 31 ) 21
62: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 37
63: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 38
64: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 39
65: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 25
  0:   On '}' to state 44 with (0 )
  1:   On statement_list to state 45 with (1 4 )
  2:   On declaration_list to state 46 with (2 6 )
  3:   On statement to state 47 with (3 )
  4:   On declaration to state 22 with (5 )
  5:   On '{' to state 48 with (7 )
  6:   On selection_statement to state 49 with (8 )
  7:   On iteration_statement to state 50 with (9 )
  8:   On assignment_statement to state 51 with (10 )
  9:   On RETURN to state 52 with (11 )
  10:   On type_specifier to state 23 with (12 )
  11:   On IF to state 53 with (13 )
  12:   On WHILE to state 54 with (14 )
  13:   On FOR to state 55 with (15 )
  14:   On ';' to state 56 with (16 )
  15:   On expression to state 57 with (17 )
  16:   On VOID to state 10 with (18 )
  17:   On INT to state 11 with (19 )
  18:   On FLOAT to state 12 with (20 )
  19:   On STRUCT to state 13 with (21 )
  20:   On logical_or_expression to state 58 with (22 25 )
  21:   On l_expression to state 59 with (23 27 29 30 61 )
  22:   On logical_and_expression to state 60 with (24 33 )
  23:   On IDENTIFIER to state 61 with (26 51 52 )
  24:   On '*' to state 62 with (28 60 )
  25:   On '(' to state 63 with (31 65 )
  26:   On equality_expression to state 64 with (32 35 36 )
  27:   On relational_expression to state 65 with (34 38 39 40 41 )
  28:   On additive_expression to state 66 with (37 43 44 )
  29:   On multiplicative_expression to state 67 with (42 46 47 )
  30:   On unary_expression to state 68 with (45 )
  31:   On postfix_expression to state 69 with (48 53 54 55 56 )
  32:   On unary_operator to state 70 with (49 )
  33:   On primary_expression to state 71 with (50 )
  34:   On '-' to state 72 with (57 )
  35:   On '!' to state 73 with (58 )
  36:   On '&' to state 74 with (59 )
  37:   On INT_CONSTANT to state 75 with (62 )
  38:   On FLOAT_CONSTANT to state 76 with (63 )
  39:   On STRING_LITERAL to state 77 with (64 )


State 35:
0: [P15 3] fun_declarator -> IDENTIFIER '(' parameter_list  . ')'   { '{' }  0, () 0
1: [P19 1] parameter_list -> parameter_list  . ',' parameter_declaration   { ')' ',' }  0, () 1
  0:   On ')' to state 78 with (0 )
  1:   On ',' to state 79 with (1 )


State 36:
0: [P16 3] fun_declarator -> IDENTIFIER '(' ')'  .   { '{' }  1, () -1
  Reduce item(s): 0 


State 37:
0: [P18 1] parameter_list -> parameter_declaration  .   { ')' ',' }  1, () -1
  Reduce item(s): 0 


State 38:
0: [P20 1] parameter_declaration -> type_specifier  . declarator   { ')' ',' }  0, (1 2 3 ) 0
1: [P21 0] declarator ->  . IDENTIFIER   { ')' ',' '[' }  0, () 1
2: [P22 0] declarator ->  . declarator '[' primary_expression ']'   { ')' ',' '[' }  0, (1 2 3 ) 0
3: [P23 0] declarator ->  . '*' declarator   { ')' ',' '[' }  0, () 2
  0:   On declarator to state 80 with (0 2 )
  1:   On IDENTIFIER to state 31 with (1 )
  2:   On '*' to state 32 with (3 )


State 39:
0: [P5 7] struct_specifier -> #0001 STRUCT IDENTIFIER '{' declaration_list '}' ';'  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 40:
0: [P87 3] declaration -> type_specifier declarator_list ';'  .   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 41:
0: [P89 2] declarator_list -> declarator_list ','  . declarator   { ';' ',' }  0, (1 2 3 ) 0
1: [P21 0] declarator ->  . IDENTIFIER   { ';' ',' '[' }  0, () 1
2: [P22 0] declarator ->  . declarator '[' primary_expression ']'   { ';' ',' '[' }  0, (1 2 3 ) 0
3: [P23 0] declarator ->  . '*' declarator   { ';' ',' '[' }  0, () 2
  0:   On declarator to state 81 with (0 2 )
  1:   On IDENTIFIER to state 31 with (1 )
  2:   On '*' to state 32 with (3 )


State 42:
0: [P22 2] declarator -> declarator '['  . primary_expression ']'   { ';' ')' ',' '[' }  0, (1 2 3 4 5 ) 0
1: [P24 0] primary_expression ->  . l_expression   { ']' }  0, (6 7 8 9 10 11 ) 1
2: [P25 0] primary_expression ->  . INT_CONSTANT   { ']' }  0, () 2
3: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { ']' }  0, () 3
4: [P27 0] primary_expression ->  . STRING_LITERAL   { ']' }  0, () 4
5: [P28 0] primary_expression ->  . '(' expression ')'   { ']' }  0, () 5
6: [P70 0] l_expression ->  . IDENTIFIER   { PTR_OP '.' '[' ']' }  0, () 6
7: [P71 0] l_expression ->  . l_expression '[' expression ']'   { PTR_OP '.' '[' ']' }  0, (6 7 8 9 10 11 ) 1
8: [P72 0] l_expression ->  . '*' l_expression   { PTR_OP '.' '[' ']' }  0, () 7
9: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { PTR_OP '.' '[' ']' }  0, (6 7 8 9 10 11 ) 1
10: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { PTR_OP '.' '[' ']' }  0, (6 7 8 9 10 11 ) 1
11: [P75 0] l_expression ->  . '(' l_expression ')'   { PTR_OP '.' '[' ']' }  0, () 5
  0:   On primary_expression to state 82 with (0 )
  1:   On l_expression to state 83 with (1 7 9 10 )
  2:   On INT_CONSTANT to state 75 with (2 )
  3:   On FLOAT_CONSTANT to state 76 with (3 )
  4:   On STRING_LITERAL to state 77 with (4 )
  5:   On '(' to state 63 with (5 11 )
  6:   On IDENTIFIER to state 84 with (6 )
  7:   On '*' to state 85 with (8 )


State 43:
0: [P23 2] declarator -> '*' declarator  .   { ';' ')' ',' }  1, () -1
1: [P22 1] declarator -> declarator  . '[' primary_expression ']'   { ';' ')' ',' '[' }  0, () 0
  0:   On '[' to state 42 with (1 )
  Reduce item(s): 0 
Solved SR CONFLICT on '[':
	shift to state 42, removed '[' from LA-set of rule 23)


State 44:
0: [P29 2] compound_statement -> '{' '}'  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 45:
0: [P30 2] compound_statement -> '{' statement_list  . '}'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
1: [P33 1] statement_list -> statement_list  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (2 3 4 5 6 ) 1
2: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 2
3: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 ) 3
4: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (8 9 ) 4
5: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (10 11 ) 5
6: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
7: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
8: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
9: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
10: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 10
11: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (12 13 ) 11
12: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (14 15 ) 12
13: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (16 17 18 19 20 21 ) 13
14: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (22 23 ) 14
15: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (14 15 ) 12
16: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
17: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
18: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
19: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
20: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
21: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 17
22: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (24 25 26 ) 18
23: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (22 23 ) 14
24: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (27 28 29 30 31 ) 19
25: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (24 25 26 ) 18
26: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (24 25 26 ) 18
27: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (32 33 34 ) 20
28: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
29: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
30: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
31: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
32: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (35 36 37 ) 21
33: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (32 33 34 ) 20
34: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (32 33 34 ) 20
35: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (38 39 ) 22
36: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (35 36 37 ) 21
37: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (35 36 37 ) 21
38: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
39: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (47 48 49 50 ) 24
40: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (51 52 53 54 55 ) 25
41: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
42: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
43: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
44: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
45: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
46: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
47: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 28
50: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
51: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
52: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 31
55: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 17
  0:   On '}' to state 86 with (0 )
  1:   On statement to state 87 with (1 )
  2:   On '{' to state 48 with (2 )
  3:   On selection_statement to state 49 with (3 )
  4:   On iteration_statement to state 50 with (4 )
  5:   On assignment_statement to state 51 with (5 )
  6:   On RETURN to state 52 with (6 )
  7:   On IF to state 53 with (7 )
  8:   On WHILE to state 54 with (8 )
  9:   On FOR to state 55 with (9 )
  10:   On ';' to state 56 with (10 )
  11:   On expression to state 57 with (11 )
  12:   On logical_or_expression to state 58 with (12 15 )
  13:   On l_expression to state 59 with (13 17 19 20 51 )
  14:   On logical_and_expression to state 60 with (14 23 )
  15:   On IDENTIFIER to state 61 with (16 41 42 )
  16:   On '*' to state 62 with (18 50 )
  17:   On '(' to state 63 with (21 55 )
  18:   On equality_expression to state 64 with (22 25 26 )
  19:   On relational_expression to state 65 with (24 28 29 30 31 )
  20:   On additive_expression to state 66 with (27 33 34 )
  21:   On multiplicative_expression to state 67 with (32 36 37 )
  22:   On unary_expression to state 68 with (35 )
  23:   On postfix_expression to state 69 with (38 43 44 45 46 )
  24:   On unary_operator to state 70 with (39 )
  25:   On primary_expression to state 71 with (40 )
  26:   On '-' to state 72 with (47 )
  27:   On '!' to state 73 with (48 )
  28:   On '&' to state 74 with (49 )
  29:   On INT_CONSTANT to state 75 with (52 )
  30:   On FLOAT_CONSTANT to state 76 with (53 )
  31:   On STRING_LITERAL to state 77 with (54 )


State 46:
0: [P31 2] compound_statement -> '{' declaration_list  . statement_list '}'   { FLOAT VOID INT STRUCT <EOF> }  0, (2 3 ) 0
1: [P86 1] declaration_list -> declaration_list  . declaration   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }  0, (4 ) 1
2: [P32 0] statement_list ->  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (5 6 7 8 9 ) 2
3: [P33 0] statement_list ->  . statement_list statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (2 3 ) 0
4: [P87 0] declaration ->  . type_specifier declarator_list ';'   { FLOAT FLOAT_CONSTANT VOID INT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN STRUCT IDENTIFIER '{' ';' '*' '(' '-' '!' '&' }  0, (10 11 12 13 ) 3
5: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 4
6: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (14 ) 5
7: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (15 16 ) 6
8: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (17 18 ) 7
9: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
10: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 9
11: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 10
12: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 11
13: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 12
14: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 13
15: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 14
16: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 15
17: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 16
18: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (19 20 ) 17
19: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (21 22 ) 18
20: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (23 24 25 26 27 28 ) 19
21: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (29 30 ) 20
22: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (21 22 ) 18
23: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 21
24: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (23 24 25 26 27 28 ) 19
25: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 22
26: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (23 24 25 26 27 28 ) 19
27: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (23 24 25 26 27 28 ) 19
28: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 23
29: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (31 32 33 ) 24
30: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (29 30 ) 20
31: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (34 35 36 37 38 ) 25
32: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (31 32 33 ) 24
33: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (31 32 33 ) 24
34: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (39 40 41 ) 26
35: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (34 35 36 37 38 ) 25
36: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (34 35 36 37 38 ) 25
37: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (34 35 36 37 38 ) 25
38: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (34 35 36 37 38 ) 25
39: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (42 43 44 ) 27
40: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (39 40 41 ) 26
41: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (39 40 41 ) 26
42: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (45 46 ) 28
43: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (42 43 44 ) 27
44: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (42 43 44 ) 27
45: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (47 48 49 50 51 52 53 ) 29
46: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (54 55 56 57 ) 30
47: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (58 59 60 61 62 ) 31
48: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 21
49: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 21
50: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (47 48 49 50 51 52 53 ) 29
51: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (47 48 49 50 51 52 53 ) 29
52: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (47 48 49 50 51 52 53 ) 29
53: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (47 48 49 50 51 52 53 ) 29
54: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 32
55: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 33
56: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 34
57: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 22
58: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (23 24 25 26 27 28 ) 19
59: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 35
60: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 36
61: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 37
62: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 23
  0:   On statement_list to state 88 with (0 3 )
  1:   On declaration to state 28 with (1 )
  2:   On statement to state 47 with (2 )
  3:   On type_specifier to state 23 with (4 )
  4:   On '{' to state 48 with (5 )
  5:   On selection_statement to state 49 with (6 )
  6:   On iteration_statement to state 50 with (7 )
  7:   On assignment_statement to state 51 with (8 )
  8:   On RETURN to state 52 with (9 )
  9:   On VOID to state 10 with (10 )
  10:   On INT to state 11 with (11 )
  11:   On FLOAT to state 12 with (12 )
  12:   On STRUCT to state 13 with (13 )
  13:   On IF to state 53 with (14 )
  14:   On WHILE to state 54 with (15 )
  15:   On FOR to state 55 with (16 )
  16:   On ';' to state 56 with (17 )
  17:   On expression to state 57 with (18 )
  18:   On logical_or_expression to state 58 with (19 22 )
  19:   On l_expression to state 59 with (20 24 26 27 58 )
  20:   On logical_and_expression to state 60 with (21 30 )
  21:   On IDENTIFIER to state 61 with (23 48 49 )
  22:   On '*' to state 62 with (25 57 )
  23:   On '(' to state 63 with (28 62 )
  24:   On equality_expression to state 64 with (29 32 33 )
  25:   On relational_expression to state 65 with (31 35 36 37 38 )
  26:   On additive_expression to state 66 with (34 40 41 )
  27:   On multiplicative_expression to state 67 with (39 43 44 )
  28:   On unary_expression to state 68 with (42 )
  29:   On postfix_expression to state 69 with (45 50 51 52 53 )
  30:   On unary_operator to state 70 with (46 )
  31:   On primary_expression to state 71 with (47 )
  32:   On '-' to state 72 with (54 )
  33:   On '!' to state 73 with (55 )
  34:   On '&' to state 74 with (56 )
  35:   On INT_CONSTANT to state 75 with (59 )
  36:   On FLOAT_CONSTANT to state 76 with (60 )
  37:   On STRING_LITERAL to state 77 with (61 )


State 47:
0: [P32 1] statement_list -> statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 48:
0: [P34 1] statement -> '{'  . statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P32 0] statement_list ->  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (3 4 5 6 7 ) 1
2: [P33 0] statement_list ->  . statement_list statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
3: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 2
4: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (8 ) 3
5: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (9 10 ) 4
6: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (11 12 ) 5
7: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
8: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
9: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
10: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
11: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 10
12: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (13 14 ) 11
13: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (15 16 ) 12
14: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (17 18 19 20 21 22 ) 13
15: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (23 24 ) 14
16: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (15 16 ) 12
17: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
18: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 ) 13
19: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
20: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 ) 13
21: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 ) 13
22: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 17
23: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (25 26 27 ) 18
24: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (23 24 ) 14
25: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (28 29 30 31 32 ) 19
26: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (25 26 27 ) 18
27: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (25 26 27 ) 18
28: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (33 34 35 ) 20
29: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (28 29 30 31 32 ) 19
30: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (28 29 30 31 32 ) 19
31: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (28 29 30 31 32 ) 19
32: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (28 29 30 31 32 ) 19
33: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (36 37 38 ) 21
34: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (33 34 35 ) 20
35: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (33 34 35 ) 20
36: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (39 40 ) 22
37: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (36 37 38 ) 21
38: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (36 37 38 ) 21
39: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (41 42 43 44 45 46 47 ) 23
40: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (48 49 50 51 ) 24
41: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (52 53 54 55 56 ) 25
42: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
43: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
44: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (41 42 43 44 45 46 47 ) 23
45: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (41 42 43 44 45 46 47 ) 23
46: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (41 42 43 44 45 46 47 ) 23
47: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (41 42 43 44 45 46 47 ) 23
48: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
49: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
50: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 28
51: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
52: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 ) 13
53: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
54: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
55: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 31
56: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 17
  0:   On statement_list to state 89 with (0 2 )
  1:   On statement to state 47 with (1 )
  2:   On '{' to state 48 with (3 )
  3:   On selection_statement to state 49 with (4 )
  4:   On iteration_statement to state 50 with (5 )
  5:   On assignment_statement to state 51 with (6 )
  6:   On RETURN to state 52 with (7 )
  7:   On IF to state 53 with (8 )
  8:   On WHILE to state 54 with (9 )
  9:   On FOR to state 55 with (10 )
  10:   On ';' to state 56 with (11 )
  11:   On expression to state 57 with (12 )
  12:   On logical_or_expression to state 58 with (13 16 )
  13:   On l_expression to state 59 with (14 18 20 21 52 )
  14:   On logical_and_expression to state 60 with (15 24 )
  15:   On IDENTIFIER to state 61 with (17 42 43 )
  16:   On '*' to state 62 with (19 51 )
  17:   On '(' to state 63 with (22 56 )
  18:   On equality_expression to state 64 with (23 26 27 )
  19:   On relational_expression to state 65 with (25 29 30 31 32 )
  20:   On additive_expression to state 66 with (28 34 35 )
  21:   On multiplicative_expression to state 67 with (33 37 38 )
  22:   On unary_expression to state 68 with (36 )
  23:   On postfix_expression to state 69 with (39 44 45 46 47 )
  24:   On unary_operator to state 70 with (40 )
  25:   On primary_expression to state 71 with (41 )
  26:   On '-' to state 72 with (48 )
  27:   On '!' to state 73 with (49 )
  28:   On '&' to state 74 with (50 )
  29:   On INT_CONSTANT to state 75 with (53 )
  30:   On FLOAT_CONSTANT to state 76 with (54 )
  31:   On STRING_LITERAL to state 77 with (55 )


State 49:
0: [P35 1] statement -> selection_statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 50:
0: [P36 1] statement -> iteration_statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 51:
0: [P37 1] statement -> assignment_statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 52:
0: [P38 1] statement -> RETURN  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 90 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 53:
0: [P82 1] selection_statement -> IF  . '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On '(' to state 91 with (0 )


State 54:
0: [P83 1] iteration_statement -> WHILE  . '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On '(' to state 92 with (0 )


State 55:
0: [P84 1] iteration_statement -> FOR  . '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On '(' to state 93 with (0 )


State 56:
0: [P39 1] assignment_statement -> ';'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 57:
0: [P40 1] assignment_statement -> expression  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ';' to state 94 with (0 )


State 58:
0: [P41 1] expression -> logical_or_expression  .   { ';' ')' ',' ']' }  1, () -1
1: [P44 1] logical_or_expression -> logical_or_expression  . OR_OP logical_and_expression   { OR_OP ';' ')' ',' ']' }  0, () 0
  0:   On OR_OP to state 95 with (1 )
  Reduce item(s): 0 


State 59:
0: [P42 1] expression -> l_expression  . '=' expression   { ';' ')' ',' ']' }  0, () 0
1: [P71 1] l_expression -> l_expression  . '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 1
2: [P73 1] l_expression -> l_expression  . '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 2
3: [P74 1] l_expression -> l_expression  . PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 3
4: [P24 1] primary_expression -> l_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
  0:   On '=' to state 96 with (0 )
  1:   On '[' to state 97 with (1 )
  2:   On '.' to state 98 with (2 )
  3:   On PTR_OP to state 99 with (3 )
  Reduce item(s): 4 
Solved SR CONFLICT on '[':
	shift to state 97, removed '[' from LA-set of rule 24)
Solved SR CONFLICT on '.':
	shift to state 98, removed '.' from LA-set of rule 24)
Solved SR CONFLICT on PTR_OP:
	shift to state 99, removed PTR_OP from LA-set of rule 24)


State 60:
0: [P43 1] logical_or_expression -> logical_and_expression  .   { OR_OP ';' ')' ',' ']' }  1, () -1
1: [P46 1] logical_and_expression -> logical_and_expression  . AND_OP equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, () 0
  0:   On AND_OP to state 100 with (1 )
  Reduce item(s): 0 


State 61:
0: [P70 1] l_expression -> IDENTIFIER  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
1: [P64 1] postfix_expression -> IDENTIFIER  . '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P65 1] postfix_expression -> IDENTIFIER  . '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
  0:   On '(' to state 101 with (1 2 )
  Reduce item(s): 0 


State 62:
0: [P72 1] l_expression -> '*'  . l_expression   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
1: [P81 1] unary_operator -> '*'  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL INC_OP PTR_OP '.' ';' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
2: [P70 0] l_expression ->  . IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 1
3: [P71 0] l_expression ->  . l_expression '[' expression ']'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
4: [P72 0] l_expression ->  . '*' l_expression   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 2
5: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
6: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
7: [P75 0] l_expression ->  . '(' l_expression ')'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 3
  0:   On l_expression to state 102 with (0 3 5 6 )
  1:   On IDENTIFIER to state 84 with (2 )
  2:   On '*' to state 85 with (4 )
  3:   On '(' to state 103 with (7 )
  Reduce item(s): 1 
Solved SR CONFLICT on IDENTIFIER:
	shift to state 84, removed IDENTIFIER from LA-set of rule 81)
Solved SR CONFLICT on '*':
	shift to state 85, removed '*' from LA-set of rule 81)
Solved SR CONFLICT on '(':
	shift to state 103, removed '(' from LA-set of rule 81)


State 63:
0: [P75 1] l_expression -> '('  . l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
1: [P28 1] primary_expression -> '('  . expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (8 9 ) 1
2: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 2
3: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
4: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 3
5: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
6: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
7: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
8: [P41 0] expression ->  . logical_or_expression   { ')' }  0, (10 11 ) 5
9: [P42 0] expression ->  . l_expression '=' expression   { ')' }  0, (2 3 4 5 6 7 ) 0
10: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ')' }  0, (12 13 ) 6
11: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ')' }  0, (10 11 ) 5
12: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ')' }  0, (14 15 16 ) 7
13: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ')' }  0, (12 13 ) 6
14: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (17 18 19 20 21 ) 8
15: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (14 15 16 ) 7
16: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (14 15 16 ) 7
17: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (22 23 24 ) 9
18: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (17 18 19 20 21 ) 8
19: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (17 18 19 20 21 ) 8
20: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (17 18 19 20 21 ) 8
21: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (17 18 19 20 21 ) 8
22: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (25 26 27 ) 10
23: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (22 23 24 ) 9
24: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (22 23 24 ) 9
25: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (28 29 ) 11
26: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (25 26 27 ) 10
27: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (25 26 27 ) 10
28: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 36 ) 12
29: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (37 38 39 40 ) 13
30: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (41 42 43 44 45 ) 14
31: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 2
32: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 2
33: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 36 ) 12
34: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 36 ) 12
35: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 36 ) 12
36: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 36 ) 12
37: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
38: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
39: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
40: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 3
41: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (2 3 4 5 6 7 ) 0
42: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 18
43: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 19
44: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 20
45: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
  0:   On l_expression to state 104 with (0 3 5 6 9 41 )
  1:   On expression to state 105 with (1 )
  2:   On IDENTIFIER to state 61 with (2 31 32 )
  3:   On '*' to state 62 with (4 40 )
  4:   On '(' to state 63 with (7 45 )
  5:   On logical_or_expression to state 58 with (8 11 )
  6:   On logical_and_expression to state 60 with (10 13 )
  7:   On equality_expression to state 64 with (12 15 16 )
  8:   On relational_expression to state 65 with (14 18 19 20 21 )
  9:   On additive_expression to state 66 with (17 23 24 )
  10:   On multiplicative_expression to state 67 with (22 26 27 )
  11:   On unary_expression to state 68 with (25 )
  12:   On postfix_expression to state 69 with (28 33 34 35 36 )
  13:   On unary_operator to state 70 with (29 )
  14:   On primary_expression to state 71 with (30 )
  15:   On '-' to state 72 with (37 )
  16:   On '!' to state 73 with (38 )
  17:   On '&' to state 74 with (39 )
  18:   On INT_CONSTANT to state 75 with (42 )
  19:   On FLOAT_CONSTANT to state 76 with (43 )
  20:   On STRING_LITERAL to state 77 with (44 )


State 64:
0: [P45 1] logical_and_expression -> equality_expression  .   { AND_OP OR_OP ';' ')' ',' ']' }  1, () -1
1: [P48 1] equality_expression -> equality_expression  . EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, () 0
2: [P49 1] equality_expression -> equality_expression  . NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, () 1
  0:   On EQ_OP to state 106 with (1 )
  1:   On NE_OP to state 107 with (2 )
  Reduce item(s): 0 


State 65:
0: [P47 1] equality_expression -> relational_expression  .   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  1, () -1
1: [P51 1] relational_expression -> relational_expression  . '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 0
2: [P52 1] relational_expression -> relational_expression  . '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 1
3: [P53 1] relational_expression -> relational_expression  . LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 2
4: [P54 1] relational_expression -> relational_expression  . GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 3
  0:   On '<' to state 108 with (1 )
  1:   On '>' to state 109 with (2 )
  2:   On LE_OP to state 110 with (3 )
  3:   On GE_OP to state 111 with (4 )
  Reduce item(s): 0 


State 66:
0: [P50 1] relational_expression -> additive_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  1, () -1
1: [P56 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 0
2: [P57 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 1
  0:   On '+' to state 112 with (1 )
  1:   On '-' to state 113 with (2 )
  Reduce item(s): 0 


State 67:
0: [P55 1] additive_expression -> multiplicative_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  1, () -1
1: [P59 1] multiplicative_expression -> multiplicative_expression  . '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P60 1] multiplicative_expression -> multiplicative_expression  . '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, () 1
  0:   On '*' to state 114 with (1 )
  1:   On '/' to state 115 with (2 )
  Reduce item(s): 0 


State 68:
0: [P58 1] multiplicative_expression -> unary_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 69:
0: [P61 1] unary_expression -> postfix_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
1: [P66 1] postfix_expression -> postfix_expression  . '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P67 1] postfix_expression -> postfix_expression  . '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 1
3: [P68 1] postfix_expression -> postfix_expression  . PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 2
4: [P69 1] postfix_expression -> postfix_expression  . INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 3
  0:   On '[' to state 116 with (1 )
  1:   On '.' to state 117 with (2 )
  2:   On PTR_OP to state 118 with (3 )
  3:   On INC_OP to state 119 with (4 )
  Reduce item(s): 0 


State 70:
0: [P62 1] unary_expression -> unary_operator  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 7 ) 0
1: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (8 9 10 11 12 ) 1
2: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 2
3: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 2
4: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 7 ) 0
5: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 7 ) 0
6: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 7 ) 0
7: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 7 ) 0
8: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (13 14 15 16 17 18 ) 3
9: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
10: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
11: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
12: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
13: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 2
14: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (13 14 15 16 17 18 ) 3
15: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 8
16: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (13 14 15 16 17 18 ) 3
17: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (13 14 15 16 17 18 ) 3
18: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
  0:   On postfix_expression to state 120 with (0 4 5 6 7 )
  1:   On primary_expression to state 71 with (1 )
  2:   On IDENTIFIER to state 61 with (2 3 13 )
  3:   On l_expression to state 83 with (8 14 16 17 )
  4:   On INT_CONSTANT to state 75 with (9 )
  5:   On FLOAT_CONSTANT to state 76 with (10 )
  6:   On STRING_LITERAL to state 77 with (11 )
  7:   On '(' to state 63 with (12 18 )
  8:   On '*' to state 85 with (15 )


State 71:
0: [P63 1] postfix_expression -> primary_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 72:
0: [P78 1] unary_operator -> '-'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  1, () -1
  Reduce item(s): 0 


State 73:
0: [P79 1] unary_operator -> '!'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  1, () -1
  Reduce item(s): 0 


State 74:
0: [P80 1] unary_operator -> '&'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  1, () -1
  Reduce item(s): 0 


State 75:
0: [P25 1] primary_expression -> INT_CONSTANT  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 76:
0: [P26 1] primary_expression -> FLOAT_CONSTANT  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 77:
0: [P27 1] primary_expression -> STRING_LITERAL  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 78:
0: [P15 4] fun_declarator -> IDENTIFIER '(' parameter_list ')'  .   { '{' }  1, () -1
  Reduce item(s): 0 


State 79:
0: [P19 2] parameter_list -> parameter_list ','  . parameter_declaration   { ')' ',' }  0, (1 ) 0
1: [P20 0] parameter_declaration ->  . type_specifier declarator   { ')' ',' }  0, (2 3 4 5 ) 1
2: [P11 0] type_specifier ->  . VOID   { IDENTIFIER '*' }  0, () 2
3: [P12 0] type_specifier ->  . INT   { IDENTIFIER '*' }  0, () 3
4: [P13 0] type_specifier ->  . FLOAT   { IDENTIFIER '*' }  0, () 4
5: [P14 0] type_specifier ->  . STRUCT IDENTIFIER   { IDENTIFIER '*' }  0, () 5
  0:   On parameter_declaration to state 121 with (0 )
  1:   On type_specifier to state 38 with (1 )
  2:   On VOID to state 10 with (2 )
  3:   On INT to state 11 with (3 )
  4:   On FLOAT to state 12 with (4 )
  5:   On STRUCT to state 13 with (5 )


State 80:
0: [P20 2] parameter_declaration -> type_specifier declarator  .   { ')' ',' }  1, () -1
1: [P22 1] declarator -> declarator  . '[' primary_expression ']'   { ')' ',' '[' }  0, () 0
  0:   On '[' to state 42 with (1 )
  Reduce item(s): 0 


State 81:
0: [P89 3] declarator_list -> declarator_list ',' declarator  .   { ';' ',' }  1, () -1
1: [P22 1] declarator -> declarator  . '[' primary_expression ']'   { ';' ',' '[' }  0, () 0
  0:   On '[' to state 42 with (1 )
  Reduce item(s): 0 


State 82:
0: [P22 3] declarator -> declarator '[' primary_expression  . ']'   { ';' ')' ',' '[' }  0, () 0
  0:   On ']' to state 122 with (0 )


State 83:
0: [P24 1] primary_expression -> l_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
1: [P71 1] l_expression -> l_expression  . '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P73 1] l_expression -> l_expression  . '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 1
3: [P74 1] l_expression -> l_expression  . PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 2
  0:   On '[' to state 97 with (1 )
  1:   On '.' to state 98 with (2 )
  2:   On PTR_OP to state 99 with (3 )
  Reduce item(s): 0 
Solved SR CONFLICT on '[':
	shift to state 97, removed '[' from LA-set of rule 24)
Solved SR CONFLICT on '.':
	shift to state 98, removed '.' from LA-set of rule 24)
Solved SR CONFLICT on PTR_OP:
	shift to state 99, removed PTR_OP from LA-set of rule 24)


State 84:
0: [P70 1] l_expression -> IDENTIFIER  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 85:
0: [P72 1] l_expression -> '*'  . l_expression   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 ) 0
1: [P70 0] l_expression ->  . IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 1
2: [P71 0] l_expression ->  . l_expression '[' expression ']'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 ) 0
3: [P72 0] l_expression ->  . '*' l_expression   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 2
4: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 ) 0
5: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 ) 0
6: [P75 0] l_expression ->  . '(' l_expression ')'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 3
  0:   On l_expression to state 102 with (0 2 4 5 )
  1:   On IDENTIFIER to state 84 with (1 )
  2:   On '*' to state 85 with (3 )
  3:   On '(' to state 103 with (6 )


State 86:
0: [P30 3] compound_statement -> '{' statement_list '}'  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 87:
0: [P33 2] statement_list -> statement_list statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 88:
0: [P31 3] compound_statement -> '{' declaration_list statement_list  . '}'   { FLOAT VOID INT STRUCT <EOF> }  0, () 0
1: [P33 1] statement_list -> statement_list  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (2 3 4 5 6 ) 1
2: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 2
3: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 ) 3
4: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (8 9 ) 4
5: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (10 11 ) 5
6: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
7: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
8: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
9: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
10: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 10
11: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (12 13 ) 11
12: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (14 15 ) 12
13: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (16 17 18 19 20 21 ) 13
14: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (22 23 ) 14
15: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (14 15 ) 12
16: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
17: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
18: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
19: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
20: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
21: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 17
22: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (24 25 26 ) 18
23: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (22 23 ) 14
24: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (27 28 29 30 31 ) 19
25: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (24 25 26 ) 18
26: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (24 25 26 ) 18
27: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (32 33 34 ) 20
28: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
29: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
30: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
31: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
32: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (35 36 37 ) 21
33: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (32 33 34 ) 20
34: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (32 33 34 ) 20
35: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (38 39 ) 22
36: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (35 36 37 ) 21
37: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (35 36 37 ) 21
38: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
39: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (47 48 49 50 ) 24
40: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (51 52 53 54 55 ) 25
41: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
42: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
43: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
44: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
45: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
46: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
47: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 28
50: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
51: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
52: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 31
55: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 17
  0:   On '}' to state 123 with (0 )
  1:   On statement to state 87 with (1 )
  2:   On '{' to state 48 with (2 )
  3:   On selection_statement to state 49 with (3 )
  4:   On iteration_statement to state 50 with (4 )
  5:   On assignment_statement to state 51 with (5 )
  6:   On RETURN to state 52 with (6 )
  7:   On IF to state 53 with (7 )
  8:   On WHILE to state 54 with (8 )
  9:   On FOR to state 55 with (9 )
  10:   On ';' to state 56 with (10 )
  11:   On expression to state 57 with (11 )
  12:   On logical_or_expression to state 58 with (12 15 )
  13:   On l_expression to state 59 with (13 17 19 20 51 )
  14:   On logical_and_expression to state 60 with (14 23 )
  15:   On IDENTIFIER to state 61 with (16 41 42 )
  16:   On '*' to state 62 with (18 50 )
  17:   On '(' to state 63 with (21 55 )
  18:   On equality_expression to state 64 with (22 25 26 )
  19:   On relational_expression to state 65 with (24 28 29 30 31 )
  20:   On additive_expression to state 66 with (27 33 34 )
  21:   On multiplicative_expression to state 67 with (32 36 37 )
  22:   On unary_expression to state 68 with (35 )
  23:   On postfix_expression to state 69 with (38 43 44 45 46 )
  24:   On unary_operator to state 70 with (39 )
  25:   On primary_expression to state 71 with (40 )
  26:   On '-' to state 72 with (47 )
  27:   On '!' to state 73 with (48 )
  28:   On '&' to state 74 with (49 )
  29:   On INT_CONSTANT to state 75 with (52 )
  30:   On FLOAT_CONSTANT to state 76 with (53 )
  31:   On STRING_LITERAL to state 77 with (54 )


State 89:
0: [P34 2] statement -> '{' statement_list  . '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
1: [P33 1] statement_list -> statement_list  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (2 3 4 5 6 ) 1
2: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 2
3: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 ) 3
4: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (8 9 ) 4
5: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (10 11 ) 5
6: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
7: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
8: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
9: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
10: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 10
11: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (12 13 ) 11
12: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (14 15 ) 12
13: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (16 17 18 19 20 21 ) 13
14: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (22 23 ) 14
15: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (14 15 ) 12
16: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
17: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
18: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
19: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
20: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
21: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 17
22: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (24 25 26 ) 18
23: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (22 23 ) 14
24: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (27 28 29 30 31 ) 19
25: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (24 25 26 ) 18
26: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (24 25 26 ) 18
27: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (32 33 34 ) 20
28: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
29: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
30: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
31: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (27 28 29 30 31 ) 19
32: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (35 36 37 ) 21
33: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (32 33 34 ) 20
34: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (32 33 34 ) 20
35: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (38 39 ) 22
36: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (35 36 37 ) 21
37: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (35 36 37 ) 21
38: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
39: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (47 48 49 50 ) 24
40: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (51 52 53 54 55 ) 25
41: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
42: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 15
43: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
44: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
45: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
46: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 45 46 ) 23
47: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 28
50: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
51: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (16 17 18 19 20 21 ) 13
52: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 31
55: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 17
  0:   On '}' to state 124 with (0 )
  1:   On statement to state 87 with (1 )
  2:   On '{' to state 48 with (2 )
  3:   On selection_statement to state 49 with (3 )
  4:   On iteration_statement to state 50 with (4 )
  5:   On assignment_statement to state 51 with (5 )
  6:   On RETURN to state 52 with (6 )
  7:   On IF to state 53 with (7 )
  8:   On WHILE to state 54 with (8 )
  9:   On FOR to state 55 with (9 )
  10:   On ';' to state 56 with (10 )
  11:   On expression to state 57 with (11 )
  12:   On logical_or_expression to state 58 with (12 15 )
  13:   On l_expression to state 59 with (13 17 19 20 51 )
  14:   On logical_and_expression to state 60 with (14 23 )
  15:   On IDENTIFIER to state 61 with (16 41 42 )
  16:   On '*' to state 62 with (18 50 )
  17:   On '(' to state 63 with (21 55 )
  18:   On equality_expression to state 64 with (22 25 26 )
  19:   On relational_expression to state 65 with (24 28 29 30 31 )
  20:   On additive_expression to state 66 with (27 33 34 )
  21:   On multiplicative_expression to state 67 with (32 36 37 )
  22:   On unary_expression to state 68 with (35 )
  23:   On postfix_expression to state 69 with (38 43 44 45 46 )
  24:   On unary_operator to state 70 with (39 )
  25:   On primary_expression to state 71 with (40 )
  26:   On '-' to state 72 with (47 )
  27:   On '!' to state 73 with (48 )
  28:   On '&' to state 74 with (49 )
  29:   On INT_CONSTANT to state 75 with (52 )
  30:   On FLOAT_CONSTANT to state 76 with (53 )
  31:   On STRING_LITERAL to state 77 with (54 )


State 90:
0: [P38 2] statement -> RETURN expression  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ';' to state 125 with (0 )


State 91:
0: [P82 2] selection_statement -> IF '('  . expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ')' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ')' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ')' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ')' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ')' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ')' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 126 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 92:
0: [P83 2] iteration_statement -> WHILE '('  . expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ')' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ')' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ')' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ')' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ')' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ')' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 127 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 93:
0: [P84 2] iteration_statement -> FOR '('  . expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 128 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 94:
0: [P40 2] assignment_statement -> expression ';'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 95:
0: [P44 2] logical_or_expression -> logical_or_expression OR_OP  . logical_and_expression   { OR_OP ';' ')' ',' ']' }  0, (1 2 ) 0
1: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, (3 4 5 ) 1
2: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, (1 2 ) 0
3: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (6 7 8 9 10 ) 2
4: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (3 4 5 ) 1
5: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (3 4 5 ) 1
6: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (11 12 13 ) 3
7: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (6 7 8 9 10 ) 2
8: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (6 7 8 9 10 ) 2
9: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (6 7 8 9 10 ) 2
10: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (6 7 8 9 10 ) 2
11: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (14 15 16 ) 4
12: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (11 12 13 ) 3
13: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (11 12 13 ) 3
14: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (17 18 ) 5
15: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 ) 4
16: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 ) 4
17: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 25 ) 6
18: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (26 27 28 29 ) 7
19: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 ) 8
20: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 9
21: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 9
22: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 25 ) 6
23: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 25 ) 6
24: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 25 ) 6
25: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 25 ) 6
26: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
27: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 11
28: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 12
29: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 13
30: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (35 36 37 38 39 40 ) 14
31: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
32: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 16
33: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 17
34: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 18
35: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 9
36: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (35 36 37 38 39 40 ) 14
37: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
38: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (35 36 37 38 39 40 ) 14
39: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (35 36 37 38 39 40 ) 14
40: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 18
  0:   On logical_and_expression to state 129 with (0 2 )
  1:   On equality_expression to state 64 with (1 4 5 )
  2:   On relational_expression to state 65 with (3 7 8 9 10 )
  3:   On additive_expression to state 66 with (6 12 13 )
  4:   On multiplicative_expression to state 67 with (11 15 16 )
  5:   On unary_expression to state 68 with (14 )
  6:   On postfix_expression to state 69 with (17 22 23 24 25 )
  7:   On unary_operator to state 70 with (18 )
  8:   On primary_expression to state 71 with (19 )
  9:   On IDENTIFIER to state 61 with (20 21 35 )
  10:   On '-' to state 72 with (26 )
  11:   On '!' to state 73 with (27 )
  12:   On '&' to state 74 with (28 )
  13:   On '*' to state 62 with (29 37 )
  14:   On l_expression to state 83 with (30 36 38 39 )
  15:   On INT_CONSTANT to state 75 with (31 )
  16:   On FLOAT_CONSTANT to state 76 with (32 )
  17:   On STRING_LITERAL to state 77 with (33 )
  18:   On '(' to state 63 with (34 40 )


State 96:
0: [P42 2] expression -> l_expression '='  . expression   { ';' ')' ',' ']' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ';' ')' ',' ']' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ';' ')' ',' ']' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' ')' ',' ']' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' ')' ',' ']' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 130 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 97:
0: [P71 2] l_expression -> l_expression '['  . expression ']'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ']' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ']' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ']' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ']' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ']' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ']' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ']' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ']' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ']' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 131 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 98:
0: [P73 2] l_expression -> l_expression '.'  . IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 0
  0:   On IDENTIFIER to state 132 with (0 )


State 99:
0: [P74 2] l_expression -> l_expression PTR_OP  . IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 0
  0:   On IDENTIFIER to state 133 with (0 )


State 100:
0: [P46 2] logical_and_expression -> logical_and_expression AND_OP  . equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, (1 2 3 ) 0
1: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (4 5 6 7 8 ) 1
2: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (1 2 3 ) 0
3: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (1 2 3 ) 0
4: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (9 10 11 ) 2
5: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (4 5 6 7 8 ) 1
6: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (4 5 6 7 8 ) 1
7: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (4 5 6 7 8 ) 1
8: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (4 5 6 7 8 ) 1
9: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (12 13 14 ) 3
10: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (9 10 11 ) 2
11: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (9 10 11 ) 2
12: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (15 16 ) 4
13: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (12 13 14 ) 3
14: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (12 13 14 ) 3
15: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 23 ) 5
16: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 27 ) 6
17: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (28 29 30 31 32 ) 7
18: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 8
19: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 8
20: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 23 ) 5
21: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 23 ) 5
22: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 23 ) 5
23: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 22 23 ) 5
24: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
25: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
26: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 11
27: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 12
28: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (33 34 35 36 37 38 ) 13
29: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
30: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
31: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 16
32: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 17
33: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 8
34: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (33 34 35 36 37 38 ) 13
35: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
36: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (33 34 35 36 37 38 ) 13
37: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (33 34 35 36 37 38 ) 13
38: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 17
  0:   On equality_expression to state 134 with (0 2 3 )
  1:   On relational_expression to state 65 with (1 5 6 7 8 )
  2:   On additive_expression to state 66 with (4 10 11 )
  3:   On multiplicative_expression to state 67 with (9 13 14 )
  4:   On unary_expression to state 68 with (12 )
  5:   On postfix_expression to state 69 with (15 20 21 22 23 )
  6:   On unary_operator to state 70 with (16 )
  7:   On primary_expression to state 71 with (17 )
  8:   On IDENTIFIER to state 61 with (18 19 33 )
  9:   On '-' to state 72 with (24 )
  10:   On '!' to state 73 with (25 )
  11:   On '&' to state 74 with (26 )
  12:   On '*' to state 62 with (27 35 )
  13:   On l_expression to state 83 with (28 34 36 37 )
  14:   On INT_CONSTANT to state 75 with (29 )
  15:   On FLOAT_CONSTANT to state 76 with (30 )
  16:   On STRING_LITERAL to state 77 with (31 )
  17:   On '(' to state 63 with (32 38 )


State 101:
0: [P64 2] postfix_expression -> IDENTIFIER '('  . ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
1: [P65 2] postfix_expression -> IDENTIFIER '('  . expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (2 3 ) 1
2: [P76 0] expression_list ->  . expression   { ')' ',' }  0, (4 5 ) 2
3: [P77 0] expression_list ->  . expression_list ',' expression   { ')' ',' }  0, (2 3 ) 1
4: [P41 0] expression ->  . logical_or_expression   { ')' ',' }  0, (6 7 ) 3
5: [P42 0] expression ->  . l_expression '=' expression   { ')' ',' }  0, (8 9 10 11 12 13 ) 4
6: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ')' ',' }  0, (14 15 ) 5
7: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ')' ',' }  0, (6 7 ) 3
8: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
9: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, (8 9 10 11 12 13 ) 4
10: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, () 7
11: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, (8 9 10 11 12 13 ) 4
12: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, (8 9 10 11 12 13 ) 4
13: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, () 8
14: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ')' ',' }  0, (16 17 18 ) 9
15: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ')' ',' }  0, (14 15 ) 5
16: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' ',' }  0, (19 20 21 22 23 ) 10
17: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' ',' }  0, (16 17 18 ) 9
18: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' ',' }  0, (16 17 18 ) 9
19: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (24 25 26 ) 11
20: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (19 20 21 22 23 ) 10
21: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (19 20 21 22 23 ) 10
22: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (19 20 21 22 23 ) 10
23: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (19 20 21 22 23 ) 10
24: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' '+' '-' }  0, (27 28 29 ) 12
25: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' '+' '-' }  0, (24 25 26 ) 11
26: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' '+' '-' }  0, (24 25 26 ) 11
27: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (30 31 ) 13
28: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (27 28 29 ) 12
29: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (27 28 29 ) 12
30: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (32 33 34 35 36 37 38 ) 14
31: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (39 40 41 42 ) 15
32: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (43 44 45 46 47 ) 16
33: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 6
34: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 6
35: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (32 33 34 35 36 37 38 ) 14
36: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (32 33 34 35 36 37 38 ) 14
37: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (32 33 34 35 36 37 38 ) 14
38: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (32 33 34 35 36 37 38 ) 14
39: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
40: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 18
41: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 19
42: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
43: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (8 9 10 11 12 13 ) 4
44: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 20
45: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 21
46: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 22
47: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 8
  0:   On ')' to state 135 with (0 )
  1:   On expression_list to state 136 with (1 3 )
  2:   On expression to state 137 with (2 )
  3:   On logical_or_expression to state 58 with (4 7 )
  4:   On l_expression to state 59 with (5 9 11 12 43 )
  5:   On logical_and_expression to state 60 with (6 15 )
  6:   On IDENTIFIER to state 61 with (8 33 34 )
  7:   On '*' to state 62 with (10 42 )
  8:   On '(' to state 63 with (13 47 )
  9:   On equality_expression to state 64 with (14 17 18 )
  10:   On relational_expression to state 65 with (16 20 21 22 23 )
  11:   On additive_expression to state 66 with (19 25 26 )
  12:   On multiplicative_expression to state 67 with (24 28 29 )
  13:   On unary_expression to state 68 with (27 )
  14:   On postfix_expression to state 69 with (30 35 36 37 38 )
  15:   On unary_operator to state 70 with (31 )
  16:   On primary_expression to state 71 with (32 )
  17:   On '-' to state 72 with (39 )
  18:   On '!' to state 73 with (40 )
  19:   On '&' to state 74 with (41 )
  20:   On INT_CONSTANT to state 75 with (44 )
  21:   On FLOAT_CONSTANT to state 76 with (45 )
  22:   On STRING_LITERAL to state 77 with (46 )


State 102:
0: [P72 2] l_expression -> '*' l_expression  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP ';' '*' '(' ')' ',' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
1: [P71 1] l_expression -> l_expression  . '[' expression ']'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 0
2: [P73 1] l_expression -> l_expression  . '.' IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 1
3: [P74 1] l_expression -> l_expression  . PTR_OP IDENTIFIER   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 2
  0:   On '[' to state 97 with (1 )
  1:   On '.' to state 98 with (2 )
  2:   On PTR_OP to state 99 with (3 )
  Reduce item(s): 0 
Solved SR CONFLICT on '[':
	shift to state 97, removed '[' from LA-set of rule 72)
Solved SR CONFLICT on '.':
	shift to state 98, removed '.' from LA-set of rule 72)
Solved SR CONFLICT on PTR_OP:
	shift to state 99, removed PTR_OP from LA-set of rule 72)


State 103:
0: [P75 1] l_expression -> '('  . l_expression ')'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (1 2 3 4 5 6 ) 0
1: [P70 0] l_expression ->  . IDENTIFIER   { PTR_OP '.' ')' '[' }  0, () 1
2: [P71 0] l_expression ->  . l_expression '[' expression ']'   { PTR_OP '.' ')' '[' }  0, (1 2 3 4 5 6 ) 0
3: [P72 0] l_expression ->  . '*' l_expression   { PTR_OP '.' ')' '[' }  0, () 2
4: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { PTR_OP '.' ')' '[' }  0, (1 2 3 4 5 6 ) 0
5: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { PTR_OP '.' ')' '[' }  0, (1 2 3 4 5 6 ) 0
6: [P75 0] l_expression ->  . '(' l_expression ')'   { PTR_OP '.' ')' '[' }  0, () 3
  0:   On l_expression to state 138 with (0 2 4 5 )
  1:   On IDENTIFIER to state 84 with (1 )
  2:   On '*' to state 85 with (3 )
  3:   On '(' to state 103 with (6 )


State 104:
0: [P75 2] l_expression -> '(' l_expression  . ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 0
1: [P71 1] l_expression -> l_expression  . '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 1
2: [P73 1] l_expression -> l_expression  . '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 2
3: [P74 1] l_expression -> l_expression  . PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 3
4: [P42 1] expression -> l_expression  . '=' expression   { ')' }  0, () 4
5: [P24 1] primary_expression -> l_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP '*' '<' '>' '+' '-' '/' }  1, () -1
  0:   On ')' to state 139 with (0 )
  1:   On '[' to state 97 with (1 )
  2:   On '.' to state 98 with (2 )
  3:   On PTR_OP to state 99 with (3 )
  4:   On '=' to state 96 with (4 )
  Reduce item(s): 5 
Solved SR CONFLICT on ')':
	shift to state 139, removed ')' from LA-set of rule 24)
Solved SR CONFLICT on '[':
	shift to state 97, removed '[' from LA-set of rule 24)
Solved SR CONFLICT on '.':
	shift to state 98, removed '.' from LA-set of rule 24)
Solved SR CONFLICT on PTR_OP:
	shift to state 99, removed PTR_OP from LA-set of rule 24)


State 105:
0: [P28 2] primary_expression -> '(' expression  . ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
  0:   On ')' to state 140 with (0 )


State 106:
0: [P48 2] equality_expression -> equality_expression EQ_OP  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (1 2 3 4 5 ) 0
1: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (6 7 8 ) 1
2: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
3: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
4: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
5: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
6: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (9 10 11 ) 2
7: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (6 7 8 ) 1
8: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (6 7 8 ) 1
9: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (12 13 ) 3
10: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 ) 2
11: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 ) 2
12: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
13: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (21 22 23 24 ) 5
14: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 ) 6
15: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
16: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
17: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
18: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
19: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
20: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
21: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
22: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
23: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
24: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 11
25: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
26: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
27: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
28: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
29: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 16
30: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
31: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
32: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 11
33: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
34: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
35: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 16
  0:   On relational_expression to state 141 with (0 2 3 4 5 )
  1:   On additive_expression to state 66 with (1 7 8 )
  2:   On multiplicative_expression to state 67 with (6 10 11 )
  3:   On unary_expression to state 68 with (9 )
  4:   On postfix_expression to state 69 with (12 17 18 19 20 )
  5:   On unary_operator to state 70 with (13 )
  6:   On primary_expression to state 71 with (14 )
  7:   On IDENTIFIER to state 61 with (15 16 30 )
  8:   On '-' to state 72 with (21 )
  9:   On '!' to state 73 with (22 )
  10:   On '&' to state 74 with (23 )
  11:   On '*' to state 62 with (24 32 )
  12:   On l_expression to state 83 with (25 31 33 34 )
  13:   On INT_CONSTANT to state 75 with (26 )
  14:   On FLOAT_CONSTANT to state 76 with (27 )
  15:   On STRING_LITERAL to state 77 with (28 )
  16:   On '(' to state 63 with (29 35 )


State 107:
0: [P49 2] equality_expression -> equality_expression NE_OP  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, (1 2 3 4 5 ) 0
1: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (6 7 8 ) 1
2: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
3: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
4: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
5: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 4 5 ) 0
6: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (9 10 11 ) 2
7: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (6 7 8 ) 1
8: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (6 7 8 ) 1
9: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (12 13 ) 3
10: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 ) 2
11: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 ) 2
12: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
13: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (21 22 23 24 ) 5
14: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 ) 6
15: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
16: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
17: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
18: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
19: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
20: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 19 20 ) 4
21: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
22: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
23: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
24: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 11
25: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
26: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
27: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
28: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
29: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 16
30: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 7
31: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
32: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 11
33: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
34: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (30 31 32 33 34 35 ) 12
35: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 16
  0:   On relational_expression to state 142 with (0 2 3 4 5 )
  1:   On additive_expression to state 66 with (1 7 8 )
  2:   On multiplicative_expression to state 67 with (6 10 11 )
  3:   On unary_expression to state 68 with (9 )
  4:   On postfix_expression to state 69 with (12 17 18 19 20 )
  5:   On unary_operator to state 70 with (13 )
  6:   On primary_expression to state 71 with (14 )
  7:   On IDENTIFIER to state 61 with (15 16 30 )
  8:   On '-' to state 72 with (21 )
  9:   On '!' to state 73 with (22 )
  10:   On '&' to state 74 with (23 )
  11:   On '*' to state 62 with (24 32 )
  12:   On l_expression to state 83 with (25 31 33 34 )
  13:   On INT_CONSTANT to state 75 with (26 )
  14:   On FLOAT_CONSTANT to state 76 with (27 )
  15:   On STRING_LITERAL to state 77 with (28 )
  16:   On '(' to state 63 with (29 35 )


State 108:
0: [P51 2] relational_expression -> relational_expression '<'  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 ) 0
1: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (4 5 6 ) 1
2: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
3: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
4: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (7 8 ) 2
5: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
6: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
7: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
8: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (16 17 18 19 ) 4
9: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (20 21 22 23 24 ) 5
10: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
11: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
12: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
13: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
14: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
15: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
16: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
17: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
18: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
19: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
20: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
21: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
22: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
23: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
24: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
25: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
26: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
27: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 10
28: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
29: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
30: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
  0:   On additive_expression to state 143 with (0 2 3 )
  1:   On multiplicative_expression to state 67 with (1 5 6 )
  2:   On unary_expression to state 68 with (4 )
  3:   On postfix_expression to state 69 with (7 12 13 14 15 )
  4:   On unary_operator to state 70 with (8 )
  5:   On primary_expression to state 71 with (9 )
  6:   On IDENTIFIER to state 61 with (10 11 25 )
  7:   On '-' to state 72 with (16 )
  8:   On '!' to state 73 with (17 )
  9:   On '&' to state 74 with (18 )
  10:   On '*' to state 62 with (19 27 )
  11:   On l_expression to state 83 with (20 26 28 29 )
  12:   On INT_CONSTANT to state 75 with (21 )
  13:   On FLOAT_CONSTANT to state 76 with (22 )
  14:   On STRING_LITERAL to state 77 with (23 )
  15:   On '(' to state 63 with (24 30 )


State 109:
0: [P52 2] relational_expression -> relational_expression '>'  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 ) 0
1: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (4 5 6 ) 1
2: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
3: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
4: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (7 8 ) 2
5: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
6: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
7: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
8: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (16 17 18 19 ) 4
9: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (20 21 22 23 24 ) 5
10: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
11: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
12: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
13: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
14: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
15: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
16: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
17: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
18: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
19: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
20: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
21: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
22: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
23: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
24: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
25: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
26: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
27: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 10
28: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
29: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
30: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
  0:   On additive_expression to state 144 with (0 2 3 )
  1:   On multiplicative_expression to state 67 with (1 5 6 )
  2:   On unary_expression to state 68 with (4 )
  3:   On postfix_expression to state 69 with (7 12 13 14 15 )
  4:   On unary_operator to state 70 with (8 )
  5:   On primary_expression to state 71 with (9 )
  6:   On IDENTIFIER to state 61 with (10 11 25 )
  7:   On '-' to state 72 with (16 )
  8:   On '!' to state 73 with (17 )
  9:   On '&' to state 74 with (18 )
  10:   On '*' to state 62 with (19 27 )
  11:   On l_expression to state 83 with (20 26 28 29 )
  12:   On INT_CONSTANT to state 75 with (21 )
  13:   On FLOAT_CONSTANT to state 76 with (22 )
  14:   On STRING_LITERAL to state 77 with (23 )
  15:   On '(' to state 63 with (24 30 )


State 110:
0: [P53 2] relational_expression -> relational_expression LE_OP  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 ) 0
1: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (4 5 6 ) 1
2: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
3: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
4: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (7 8 ) 2
5: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
6: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
7: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
8: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (16 17 18 19 ) 4
9: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (20 21 22 23 24 ) 5
10: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
11: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
12: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
13: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
14: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
15: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
16: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
17: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
18: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
19: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
20: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
21: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
22: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
23: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
24: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
25: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
26: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
27: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 10
28: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
29: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
30: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
  0:   On additive_expression to state 145 with (0 2 3 )
  1:   On multiplicative_expression to state 67 with (1 5 6 )
  2:   On unary_expression to state 68 with (4 )
  3:   On postfix_expression to state 69 with (7 12 13 14 15 )
  4:   On unary_operator to state 70 with (8 )
  5:   On primary_expression to state 71 with (9 )
  6:   On IDENTIFIER to state 61 with (10 11 25 )
  7:   On '-' to state 72 with (16 )
  8:   On '!' to state 73 with (17 )
  9:   On '&' to state 74 with (18 )
  10:   On '*' to state 62 with (19 27 )
  11:   On l_expression to state 83 with (20 26 28 29 )
  12:   On INT_CONSTANT to state 75 with (21 )
  13:   On FLOAT_CONSTANT to state 76 with (22 )
  14:   On STRING_LITERAL to state 77 with (23 )
  15:   On '(' to state 63 with (24 30 )


State 111:
0: [P54 2] relational_expression -> relational_expression GE_OP  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, (1 2 3 ) 0
1: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (4 5 6 ) 1
2: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
3: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
4: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (7 8 ) 2
5: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
6: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 6 ) 1
7: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
8: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (16 17 18 19 ) 4
9: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (20 21 22 23 24 ) 5
10: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
11: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
12: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
13: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
14: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
15: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (9 10 11 12 13 14 15 ) 3
16: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
17: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
18: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
19: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 10
20: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
21: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
22: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
23: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
24: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
25: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
26: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
27: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 10
28: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
29: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (25 26 27 28 29 30 ) 11
30: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 15
  0:   On additive_expression to state 146 with (0 2 3 )
  1:   On multiplicative_expression to state 67 with (1 5 6 )
  2:   On unary_expression to state 68 with (4 )
  3:   On postfix_expression to state 69 with (7 12 13 14 15 )
  4:   On unary_operator to state 70 with (8 )
  5:   On primary_expression to state 71 with (9 )
  6:   On IDENTIFIER to state 61 with (10 11 25 )
  7:   On '-' to state 72 with (16 )
  8:   On '!' to state 73 with (17 )
  9:   On '&' to state 74 with (18 )
  10:   On '*' to state 62 with (19 27 )
  11:   On l_expression to state 83 with (20 26 28 29 )
  12:   On INT_CONSTANT to state 75 with (21 )
  13:   On FLOAT_CONSTANT to state 76 with (22 )
  14:   On STRING_LITERAL to state 77 with (23 )
  15:   On '(' to state 63 with (24 30 )


State 112:
0: [P56 2] additive_expression -> additive_expression '+'  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
1: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 ) 1
2: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 ) 0
3: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 ) 0
4: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
5: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (13 14 15 16 ) 3
6: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 ) 4
7: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
8: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
9: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
10: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
11: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
12: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
13: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 6
14: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
15: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
16: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
17: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
18: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 11
19: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
20: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
21: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
22: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
23: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
24: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 9
25: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
26: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
27: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
  0:   On multiplicative_expression to state 147 with (0 2 3 )
  1:   On unary_expression to state 68 with (1 )
  2:   On postfix_expression to state 69 with (4 9 10 11 12 )
  3:   On unary_operator to state 70 with (5 )
  4:   On primary_expression to state 71 with (6 )
  5:   On IDENTIFIER to state 61 with (7 8 22 )
  6:   On '-' to state 72 with (13 )
  7:   On '!' to state 73 with (14 )
  8:   On '&' to state 74 with (15 )
  9:   On '*' to state 62 with (16 24 )
  10:   On l_expression to state 83 with (17 23 25 26 )
  11:   On INT_CONSTANT to state 75 with (18 )
  12:   On FLOAT_CONSTANT to state 76 with (19 )
  13:   On STRING_LITERAL to state 77 with (20 )
  14:   On '(' to state 63 with (21 27 )


State 113:
0: [P57 2] additive_expression -> additive_expression '-'  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, (1 2 3 ) 0
1: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (4 5 ) 1
2: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 ) 0
3: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 3 ) 0
4: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
5: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (13 14 15 16 ) 3
6: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (17 18 19 20 21 ) 4
7: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
8: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
9: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
10: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
11: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
12: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (6 7 8 9 10 11 12 ) 2
13: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 6
14: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
15: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
16: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 9
17: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
18: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 11
19: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
20: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
21: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
22: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 5
23: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
24: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 9
25: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
26: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (22 23 24 25 26 27 ) 10
27: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 14
  0:   On multiplicative_expression to state 148 with (0 2 3 )
  1:   On unary_expression to state 68 with (1 )
  2:   On postfix_expression to state 69 with (4 9 10 11 12 )
  3:   On unary_operator to state 70 with (5 )
  4:   On primary_expression to state 71 with (6 )
  5:   On IDENTIFIER to state 61 with (7 8 22 )
  6:   On '-' to state 72 with (13 )
  7:   On '!' to state 73 with (14 )
  8:   On '&' to state 74 with (15 )
  9:   On '*' to state 62 with (16 24 )
  10:   On l_expression to state 83 with (17 23 25 26 )
  11:   On INT_CONSTANT to state 75 with (18 )
  12:   On FLOAT_CONSTANT to state 76 with (19 )
  13:   On STRING_LITERAL to state 77 with (20 )
  14:   On '(' to state 63 with (21 27 )


State 114:
0: [P59 2] multiplicative_expression -> multiplicative_expression '*'  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 ) 0
1: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
2: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (10 11 12 13 ) 2
3: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 ) 3
4: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
5: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
6: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
7: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
8: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
9: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
10: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
11: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 6
12: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
13: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
14: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
15: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 10
16: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 11
17: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
18: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
19: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
20: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
21: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 8
22: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
23: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
24: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
  0:   On unary_expression to state 149 with (0 )
  1:   On postfix_expression to state 69 with (1 6 7 8 9 )
  2:   On unary_operator to state 70 with (2 )
  3:   On primary_expression to state 71 with (3 )
  4:   On IDENTIFIER to state 61 with (4 5 19 )
  5:   On '-' to state 72 with (10 )
  6:   On '!' to state 73 with (11 )
  7:   On '&' to state 74 with (12 )
  8:   On '*' to state 62 with (13 21 )
  9:   On l_expression to state 83 with (14 20 22 23 )
  10:   On INT_CONSTANT to state 75 with (15 )
  11:   On FLOAT_CONSTANT to state 76 with (16 )
  12:   On STRING_LITERAL to state 77 with (17 )
  13:   On '(' to state 63 with (18 24 )


State 115:
0: [P60 2] multiplicative_expression -> multiplicative_expression '/'  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (1 2 ) 0
1: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
2: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, (10 11 12 13 ) 2
3: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (14 15 16 17 18 ) 3
4: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
5: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
6: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
7: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
8: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
9: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (3 4 5 6 7 8 9 ) 1
10: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
11: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 6
12: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 7
13: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 8
14: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
15: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 10
16: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 11
17: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 12
18: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
19: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
20: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
21: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 8
22: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
23: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (19 20 21 22 23 24 ) 9
24: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 13
  0:   On unary_expression to state 150 with (0 )
  1:   On postfix_expression to state 69 with (1 6 7 8 9 )
  2:   On unary_operator to state 70 with (2 )
  3:   On primary_expression to state 71 with (3 )
  4:   On IDENTIFIER to state 61 with (4 5 19 )
  5:   On '-' to state 72 with (10 )
  6:   On '!' to state 73 with (11 )
  7:   On '&' to state 74 with (12 )
  8:   On '*' to state 62 with (13 21 )
  9:   On l_expression to state 83 with (14 20 22 23 )
  10:   On INT_CONSTANT to state 75 with (15 )
  11:   On FLOAT_CONSTANT to state 76 with (16 )
  12:   On STRING_LITERAL to state 77 with (17 )
  13:   On '(' to state 63 with (18 24 )


State 116:
0: [P66 2] postfix_expression -> postfix_expression '['  . expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ']' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ']' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ']' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ']' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ']' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ']' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ']' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ']' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ']' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ']' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ']' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' '[' ']' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 151 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 117:
0: [P67 2] postfix_expression -> postfix_expression '.'  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
  0:   On IDENTIFIER to state 152 with (0 )


State 118:
0: [P68 2] postfix_expression -> postfix_expression PTR_OP  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
  0:   On IDENTIFIER to state 153 with (0 )


State 119:
0: [P69 2] postfix_expression -> postfix_expression INC_OP  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 120:
0: [P62 2] unary_expression -> unary_operator postfix_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
1: [P66 1] postfix_expression -> postfix_expression  . '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P67 1] postfix_expression -> postfix_expression  . '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 1
3: [P68 1] postfix_expression -> postfix_expression  . PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 2
4: [P69 1] postfix_expression -> postfix_expression  . INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 3
  0:   On '[' to state 116 with (1 )
  1:   On '.' to state 117 with (2 )
  2:   On PTR_OP to state 118 with (3 )
  3:   On INC_OP to state 119 with (4 )
  Reduce item(s): 0 


State 121:
0: [P19 3] parameter_list -> parameter_list ',' parameter_declaration  .   { ')' ',' }  1, () -1
  Reduce item(s): 0 


State 122:
0: [P22 4] declarator -> declarator '[' primary_expression ']'  .   { ';' ')' ',' '[' }  1, () -1
  Reduce item(s): 0 


State 123:
0: [P31 4] compound_statement -> '{' declaration_list statement_list '}'  .   { FLOAT VOID INT STRUCT <EOF> }  1, () -1
  Reduce item(s): 0 


State 124:
0: [P34 3] statement -> '{' statement_list '}'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 125:
0: [P38 3] statement -> RETURN expression ';'  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 126:
0: [P82 3] selection_statement -> IF '(' expression  . ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ')' to state 154 with (0 )


State 127:
0: [P83 3] iteration_statement -> WHILE '(' expression  . ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ')' to state 155 with (0 )


State 128:
0: [P84 3] iteration_statement -> FOR '(' expression  . ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ';' to state 156 with (0 )


State 129:
0: [P44 3] logical_or_expression -> logical_or_expression OR_OP logical_and_expression  .   { OR_OP ';' ')' ',' ']' }  1, () -1
1: [P46 1] logical_and_expression -> logical_and_expression  . AND_OP equality_expression   { AND_OP OR_OP ';' ')' ',' ']' }  0, () 0
  0:   On AND_OP to state 100 with (1 )
  Reduce item(s): 0 


State 130:
0: [P42 3] expression -> l_expression '=' expression  .   { ';' ')' ',' ']' }  1, () -1
  Reduce item(s): 0 


State 131:
0: [P71 3] l_expression -> l_expression '[' expression  . ']'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 0
  0:   On ']' to state 157 with (0 )


State 132:
0: [P73 3] l_expression -> l_expression '.' IDENTIFIER  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 133:
0: [P74 3] l_expression -> l_expression PTR_OP IDENTIFIER  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 134:
0: [P46 3] logical_and_expression -> logical_and_expression AND_OP equality_expression  .   { AND_OP OR_OP ';' ')' ',' ']' }  1, () -1
1: [P48 1] equality_expression -> equality_expression  . EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, () 0
2: [P49 1] equality_expression -> equality_expression  . NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  0, () 1
  0:   On EQ_OP to state 106 with (1 )
  1:   On NE_OP to state 107 with (2 )
  Reduce item(s): 0 


State 135:
0: [P64 3] postfix_expression -> IDENTIFIER '(' ')'  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 136:
0: [P65 3] postfix_expression -> IDENTIFIER '(' expression_list  . ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
1: [P77 1] expression_list -> expression_list  . ',' expression   { ')' ',' }  0, () 1
  0:   On ')' to state 158 with (0 )
  1:   On ',' to state 159 with (1 )


State 137:
0: [P76 1] expression_list -> expression  .   { ')' ',' }  1, () -1
  Reduce item(s): 0 


State 138:
0: [P75 2] l_expression -> '(' l_expression  . ')'   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  0, () 0
1: [P71 1] l_expression -> l_expression  . '[' expression ']'   { PTR_OP '.' ')' '[' }  0, () 1
2: [P73 1] l_expression -> l_expression  . '.' IDENTIFIER   { PTR_OP '.' ')' '[' }  0, () 2
3: [P74 1] l_expression -> l_expression  . PTR_OP IDENTIFIER   { PTR_OP '.' ')' '[' }  0, () 3
  0:   On ')' to state 139 with (0 )
  1:   On '[' to state 97 with (1 )
  2:   On '.' to state 98 with (2 )
  3:   On PTR_OP to state 99 with (3 )


State 139:
0: [P75 3] l_expression -> '(' l_expression ')'  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 140:
0: [P28 3] primary_expression -> '(' expression ')'  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 141:
0: [P48 3] equality_expression -> equality_expression EQ_OP relational_expression  .   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  1, () -1
1: [P51 1] relational_expression -> relational_expression  . '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 0
2: [P52 1] relational_expression -> relational_expression  . '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 1
3: [P53 1] relational_expression -> relational_expression  . LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 2
4: [P54 1] relational_expression -> relational_expression  . GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 3
  0:   On '<' to state 108 with (1 )
  1:   On '>' to state 109 with (2 )
  2:   On LE_OP to state 110 with (3 )
  3:   On GE_OP to state 111 with (4 )
  Reduce item(s): 0 


State 142:
0: [P49 3] equality_expression -> equality_expression NE_OP relational_expression  .   { AND_OP OR_OP EQ_OP NE_OP ';' ')' ',' ']' }  1, () -1
1: [P51 1] relational_expression -> relational_expression  . '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 0
2: [P52 1] relational_expression -> relational_expression  . '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 1
3: [P53 1] relational_expression -> relational_expression  . LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 2
4: [P54 1] relational_expression -> relational_expression  . GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  0, () 3
  0:   On '<' to state 108 with (1 )
  1:   On '>' to state 109 with (2 )
  2:   On LE_OP to state 110 with (3 )
  3:   On GE_OP to state 111 with (4 )
  Reduce item(s): 0 


State 143:
0: [P51 3] relational_expression -> relational_expression '<' additive_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  1, () -1
1: [P56 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 0
2: [P57 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 1
  0:   On '+' to state 112 with (1 )
  1:   On '-' to state 113 with (2 )
  Reduce item(s): 0 


State 144:
0: [P52 3] relational_expression -> relational_expression '>' additive_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  1, () -1
1: [P56 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 0
2: [P57 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 1
  0:   On '+' to state 112 with (1 )
  1:   On '-' to state 113 with (2 )
  Reduce item(s): 0 


State 145:
0: [P53 3] relational_expression -> relational_expression LE_OP additive_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  1, () -1
1: [P56 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 0
2: [P57 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 1
  0:   On '+' to state 112 with (1 )
  1:   On '-' to state 113 with (2 )
  Reduce item(s): 0 


State 146:
0: [P54 3] relational_expression -> relational_expression GE_OP additive_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' }  1, () -1
1: [P56 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 0
2: [P57 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  0, () 1
  0:   On '+' to state 112 with (1 )
  1:   On '-' to state 113 with (2 )
  Reduce item(s): 0 


State 147:
0: [P56 3] additive_expression -> additive_expression '+' multiplicative_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  1, () -1
1: [P59 1] multiplicative_expression -> multiplicative_expression  . '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P60 1] multiplicative_expression -> multiplicative_expression  . '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, () 1
  0:   On '*' to state 114 with (1 )
  1:   On '/' to state 115 with (2 )
  Reduce item(s): 0 


State 148:
0: [P57 3] additive_expression -> additive_expression '-' multiplicative_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' ')' ',' ']' '<' '>' '+' '-' }  1, () -1
1: [P59 1] multiplicative_expression -> multiplicative_expression  . '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, () 0
2: [P60 1] multiplicative_expression -> multiplicative_expression  . '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  0, () 1
  0:   On '*' to state 114 with (1 )
  1:   On '/' to state 115 with (2 )
  Reduce item(s): 0 


State 149:
0: [P59 3] multiplicative_expression -> multiplicative_expression '*' unary_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 150:
0: [P60 3] multiplicative_expression -> multiplicative_expression '/' unary_expression  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' ')' ',' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 151:
0: [P66 3] postfix_expression -> postfix_expression '[' expression  . ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  0, () 0
  0:   On ']' to state 160 with (0 )


State 152:
0: [P67 3] postfix_expression -> postfix_expression '.' IDENTIFIER  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 153:
0: [P68 3] postfix_expression -> postfix_expression PTR_OP IDENTIFIER  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 154:
0: [P82 4] selection_statement -> IF '(' expression ')'  . statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 3 4 5 ) 0
1: [P34 0] statement ->  . '{' statement_list '}'   { ELSE }  0, () 1
2: [P35 0] statement ->  . selection_statement   { ELSE }  0, (6 ) 2
3: [P36 0] statement ->  . iteration_statement   { ELSE }  0, (7 8 ) 3
4: [P37 0] statement ->  . assignment_statement   { ELSE }  0, (9 10 ) 4
5: [P38 0] statement ->  . RETURN expression ';'   { ELSE }  0, () 5
6: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { ELSE }  0, () 6
7: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { ELSE }  0, () 7
8: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { ELSE }  0, () 8
9: [P39 0] assignment_statement ->  . ';'   { ELSE }  0, () 9
10: [P40 0] assignment_statement ->  . expression ';'   { ELSE }  0, (11 12 ) 10
11: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (13 14 ) 11
12: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (15 16 17 18 19 20 ) 12
13: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (21 22 ) 13
14: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (13 14 ) 11
15: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 14
16: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
17: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
18: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
19: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
20: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
21: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (23 24 25 ) 17
22: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (21 22 ) 13
23: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (26 27 28 29 30 ) 18
24: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
25: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
26: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (31 32 33 ) 19
27: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
28: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
29: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
30: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
31: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (34 35 36 ) 20
32: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
33: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
34: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (37 38 ) 21
35: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
36: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
37: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
38: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (46 47 48 49 ) 23
39: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 ) 24
40: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
41: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
42: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
43: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
44: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
45: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
46: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 25
47: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
50: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
51: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 28
52: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 16
  0:   On statement to state 161 with (0 )
  1:   On '{' to state 48 with (1 )
  2:   On selection_statement to state 49 with (2 )
  3:   On iteration_statement to state 50 with (3 )
  4:   On assignment_statement to state 51 with (4 )
  5:   On RETURN to state 52 with (5 )
  6:   On IF to state 53 with (6 )
  7:   On WHILE to state 54 with (7 )
  8:   On FOR to state 55 with (8 )
  9:   On ';' to state 56 with (9 )
  10:   On expression to state 57 with (10 )
  11:   On logical_or_expression to state 58 with (11 14 )
  12:   On l_expression to state 59 with (12 16 18 19 50 )
  13:   On logical_and_expression to state 60 with (13 22 )
  14:   On IDENTIFIER to state 61 with (15 40 41 )
  15:   On '*' to state 62 with (17 49 )
  16:   On '(' to state 63 with (20 54 )
  17:   On equality_expression to state 64 with (21 24 25 )
  18:   On relational_expression to state 65 with (23 27 28 29 30 )
  19:   On additive_expression to state 66 with (26 32 33 )
  20:   On multiplicative_expression to state 67 with (31 35 36 )
  21:   On unary_expression to state 68 with (34 )
  22:   On postfix_expression to state 69 with (37 42 43 44 45 )
  23:   On unary_operator to state 70 with (38 )
  24:   On primary_expression to state 71 with (39 )
  25:   On '-' to state 72 with (46 )
  26:   On '!' to state 73 with (47 )
  27:   On '&' to state 74 with (48 )
  28:   On INT_CONSTANT to state 75 with (51 )
  29:   On FLOAT_CONSTANT to state 76 with (52 )
  30:   On STRING_LITERAL to state 77 with (53 )


State 155:
0: [P83 4] iteration_statement -> WHILE '(' expression ')'  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 3 4 5 ) 0
1: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 1
2: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (6 ) 2
3: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 8 ) 3
4: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (9 10 ) 4
5: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 5
6: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
7: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
8: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
9: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
10: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (11 12 ) 10
11: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (13 14 ) 11
12: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (15 16 17 18 19 20 ) 12
13: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (21 22 ) 13
14: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (13 14 ) 11
15: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 14
16: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
17: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
18: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
19: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
20: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
21: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (23 24 25 ) 17
22: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (21 22 ) 13
23: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (26 27 28 29 30 ) 18
24: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
25: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
26: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (31 32 33 ) 19
27: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
28: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
29: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
30: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
31: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (34 35 36 ) 20
32: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
33: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
34: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (37 38 ) 21
35: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
36: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
37: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
38: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (46 47 48 49 ) 23
39: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 ) 24
40: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
41: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
42: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
43: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
44: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
45: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
46: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 25
47: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
50: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
51: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 28
52: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 16
  0:   On statement to state 162 with (0 )
  1:   On '{' to state 48 with (1 )
  2:   On selection_statement to state 49 with (2 )
  3:   On iteration_statement to state 50 with (3 )
  4:   On assignment_statement to state 51 with (4 )
  5:   On RETURN to state 52 with (5 )
  6:   On IF to state 53 with (6 )
  7:   On WHILE to state 54 with (7 )
  8:   On FOR to state 55 with (8 )
  9:   On ';' to state 56 with (9 )
  10:   On expression to state 57 with (10 )
  11:   On logical_or_expression to state 58 with (11 14 )
  12:   On l_expression to state 59 with (12 16 18 19 50 )
  13:   On logical_and_expression to state 60 with (13 22 )
  14:   On IDENTIFIER to state 61 with (15 40 41 )
  15:   On '*' to state 62 with (17 49 )
  16:   On '(' to state 63 with (20 54 )
  17:   On equality_expression to state 64 with (21 24 25 )
  18:   On relational_expression to state 65 with (23 27 28 29 30 )
  19:   On additive_expression to state 66 with (26 32 33 )
  20:   On multiplicative_expression to state 67 with (31 35 36 )
  21:   On unary_expression to state 68 with (34 )
  22:   On postfix_expression to state 69 with (37 42 43 44 45 )
  23:   On unary_operator to state 70 with (38 )
  24:   On primary_expression to state 71 with (39 )
  25:   On '-' to state 72 with (46 )
  26:   On '!' to state 73 with (47 )
  27:   On '&' to state 74 with (48 )
  28:   On INT_CONSTANT to state 75 with (51 )
  29:   On FLOAT_CONSTANT to state 76 with (52 )
  30:   On STRING_LITERAL to state 77 with (53 )


State 156:
0: [P84 4] iteration_statement -> FOR '(' expression ';'  . expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 163 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 157:
0: [P71 4] l_expression -> l_expression '[' expression ']'  .   { FLOAT_CONSTANT INT_CONSTANT AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP STRING_LITERAL IDENTIFIER INC_OP PTR_OP '.' ';' '*' '(' ')' ',' '[' ']' '=' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 158:
0: [P65 4] postfix_expression -> IDENTIFIER '(' expression_list ')'  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 159:
0: [P77 2] expression_list -> expression_list ','  . expression   { ')' ',' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ')' ',' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ')' ',' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ')' ',' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ')' ',' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ')' ',' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ')' ',' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' ',' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' ',' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' ',' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' ',' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' ',' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' ',' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 164 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 160:
0: [P66 4] postfix_expression -> postfix_expression '[' expression ']'  .   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' ')' ',' '[' ']' '<' '>' '+' '-' '/' }  1, () -1
  Reduce item(s): 0 


State 161:
0: [P82 5] selection_statement -> IF '(' expression ')' statement  . ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ELSE to state 165 with (0 )


State 162:
0: [P83 5] iteration_statement -> WHILE '(' expression ')' statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 163:
0: [P84 5] iteration_statement -> FOR '(' expression ';' expression  . ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ';' to state 166 with (0 )


State 164:
0: [P77 3] expression_list -> expression_list ',' expression  .   { ')' ',' }  1, () -1
  Reduce item(s): 0 


State 165:
0: [P82 6] selection_statement -> IF '(' expression ')' statement ELSE  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 3 4 5 ) 0
1: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 1
2: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (6 ) 2
3: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 8 ) 3
4: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (9 10 ) 4
5: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 5
6: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
7: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
8: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
9: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
10: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (11 12 ) 10
11: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (13 14 ) 11
12: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (15 16 17 18 19 20 ) 12
13: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (21 22 ) 13
14: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (13 14 ) 11
15: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 14
16: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
17: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
18: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
19: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
20: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
21: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (23 24 25 ) 17
22: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (21 22 ) 13
23: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (26 27 28 29 30 ) 18
24: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
25: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
26: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (31 32 33 ) 19
27: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
28: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
29: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
30: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
31: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (34 35 36 ) 20
32: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
33: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
34: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (37 38 ) 21
35: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
36: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
37: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
38: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (46 47 48 49 ) 23
39: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 ) 24
40: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
41: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
42: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
43: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
44: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
45: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
46: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 25
47: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
50: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
51: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 28
52: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 16
  0:   On statement to state 167 with (0 )
  1:   On '{' to state 48 with (1 )
  2:   On selection_statement to state 49 with (2 )
  3:   On iteration_statement to state 50 with (3 )
  4:   On assignment_statement to state 51 with (4 )
  5:   On RETURN to state 52 with (5 )
  6:   On IF to state 53 with (6 )
  7:   On WHILE to state 54 with (7 )
  8:   On FOR to state 55 with (8 )
  9:   On ';' to state 56 with (9 )
  10:   On expression to state 57 with (10 )
  11:   On logical_or_expression to state 58 with (11 14 )
  12:   On l_expression to state 59 with (12 16 18 19 50 )
  13:   On logical_and_expression to state 60 with (13 22 )
  14:   On IDENTIFIER to state 61 with (15 40 41 )
  15:   On '*' to state 62 with (17 49 )
  16:   On '(' to state 63 with (20 54 )
  17:   On equality_expression to state 64 with (21 24 25 )
  18:   On relational_expression to state 65 with (23 27 28 29 30 )
  19:   On additive_expression to state 66 with (26 32 33 )
  20:   On multiplicative_expression to state 67 with (31 35 36 )
  21:   On unary_expression to state 68 with (34 )
  22:   On postfix_expression to state 69 with (37 42 43 44 45 )
  23:   On unary_operator to state 70 with (38 )
  24:   On primary_expression to state 71 with (39 )
  25:   On '-' to state 72 with (46 )
  26:   On '!' to state 73 with (47 )
  27:   On '&' to state 74 with (48 )
  28:   On INT_CONSTANT to state 75 with (51 )
  29:   On FLOAT_CONSTANT to state 76 with (52 )
  30:   On STRING_LITERAL to state 77 with (53 )


State 166:
0: [P84 6] iteration_statement -> FOR '(' expression ';' expression ';'  . expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 ) 0
1: [P41 0] expression ->  . logical_or_expression   { ')' }  0, (3 4 ) 1
2: [P42 0] expression ->  . l_expression '=' expression   { ')' }  0, (5 6 7 8 9 10 ) 2
3: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ')' }  0, (11 12 ) 3
4: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ')' }  0, (3 4 ) 1
5: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 4
6: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
7: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 5
8: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
9: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
10: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '=' '<' '>' '+' '-' '/' }  0, () 6
11: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ')' }  0, (13 14 15 ) 7
12: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ')' }  0, (11 12 ) 3
13: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (16 17 18 19 20 ) 8
14: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (13 14 15 ) 7
15: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ')' }  0, (13 14 15 ) 7
16: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (21 22 23 ) 9
17: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
18: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
19: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
20: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' }  0, (16 17 18 19 20 ) 8
21: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (24 25 26 ) 10
22: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (21 22 23 ) 9
23: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ')' '<' '>' '+' '-' }  0, (21 22 23 ) 9
24: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (27 28 ) 11
25: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
26: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (24 25 26 ) 10
27: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
28: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP '*' ')' '<' '>' '+' '-' '/' }  0, (36 37 38 39 ) 13
29: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (40 41 42 43 44 ) 14
30: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
31: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 4
32: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
33: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
34: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
35: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (29 30 31 32 33 34 35 ) 12
36: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
37: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 16
38: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 17
39: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 5
40: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, (5 6 7 8 9 10 ) 2
41: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 18
42: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 19
43: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 20
44: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' '*' ')' '[' '<' '>' '+' '-' '/' }  0, () 6
  0:   On expression to state 168 with (0 )
  1:   On logical_or_expression to state 58 with (1 4 )
  2:   On l_expression to state 59 with (2 6 8 9 40 )
  3:   On logical_and_expression to state 60 with (3 12 )
  4:   On IDENTIFIER to state 61 with (5 30 31 )
  5:   On '*' to state 62 with (7 39 )
  6:   On '(' to state 63 with (10 44 )
  7:   On equality_expression to state 64 with (11 14 15 )
  8:   On relational_expression to state 65 with (13 17 18 19 20 )
  9:   On additive_expression to state 66 with (16 22 23 )
  10:   On multiplicative_expression to state 67 with (21 25 26 )
  11:   On unary_expression to state 68 with (24 )
  12:   On postfix_expression to state 69 with (27 32 33 34 35 )
  13:   On unary_operator to state 70 with (28 )
  14:   On primary_expression to state 71 with (29 )
  15:   On '-' to state 72 with (36 )
  16:   On '!' to state 73 with (37 )
  17:   On '&' to state 74 with (38 )
  18:   On INT_CONSTANT to state 75 with (41 )
  19:   On FLOAT_CONSTANT to state 76 with (42 )
  20:   On STRING_LITERAL to state 77 with (43 )


State 167:
0: [P82 7] selection_statement -> IF '(' expression ')' statement ELSE statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 


State 168:
0: [P84 7] iteration_statement -> FOR '(' expression ';' expression ';' expression  . ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 0
  0:   On ')' to state 169 with (0 )


State 169:
0: [P84 8] iteration_statement -> FOR '(' expression ';' expression ';' expression ')'  . statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (1 2 3 4 5 ) 0
1: [P34 0] statement ->  . '{' statement_list '}'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 1
2: [P35 0] statement ->  . selection_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (6 ) 2
3: [P36 0] statement ->  . iteration_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (7 8 ) 3
4: [P37 0] statement ->  . assignment_statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (9 10 ) 4
5: [P38 0] statement ->  . RETURN expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 5
6: [P82 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 6
7: [P83 0] iteration_statement ->  . WHILE '(' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 7
8: [P84 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 8
9: [P39 0] assignment_statement ->  . ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, () 9
10: [P40 0] assignment_statement ->  . expression ';'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  0, (11 12 ) 10
11: [P41 0] expression ->  . logical_or_expression   { ';' }  0, (13 14 ) 11
12: [P42 0] expression ->  . l_expression '=' expression   { ';' }  0, (15 16 17 18 19 20 ) 12
13: [P43 0] logical_or_expression ->  . logical_and_expression   { OR_OP ';' }  0, (21 22 ) 13
14: [P44 0] logical_or_expression ->  . logical_or_expression OR_OP logical_and_expression   { OR_OP ';' }  0, (13 14 ) 11
15: [P70 0] l_expression ->  . IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 14
16: [P71 0] l_expression ->  . l_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
17: [P72 0] l_expression ->  . '*' l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 15
18: [P73 0] l_expression ->  . l_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
19: [P74 0] l_expression ->  . l_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
20: [P75 0] l_expression ->  . '(' l_expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '=' '<' '>' '+' '-' '/' }  0, () 16
21: [P45 0] logical_and_expression ->  . equality_expression   { AND_OP OR_OP ';' }  0, (23 24 25 ) 17
22: [P46 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { AND_OP OR_OP ';' }  0, (21 22 ) 13
23: [P47 0] equality_expression ->  . relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (26 27 28 29 30 ) 18
24: [P48 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
25: [P49 0] equality_expression ->  . equality_expression NE_OP relational_expression   { AND_OP OR_OP EQ_OP NE_OP ';' }  0, (23 24 25 ) 17
26: [P50 0] relational_expression ->  . additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (31 32 33 ) 19
27: [P51 0] relational_expression ->  . relational_expression '<' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
28: [P52 0] relational_expression ->  . relational_expression '>' additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
29: [P53 0] relational_expression ->  . relational_expression LE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
30: [P54 0] relational_expression ->  . relational_expression GE_OP additive_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' }  0, (26 27 28 29 30 ) 18
31: [P55 0] additive_expression ->  . multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (34 35 36 ) 20
32: [P56 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
33: [P57 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '<' '>' '+' '-' }  0, (31 32 33 ) 19
34: [P58 0] multiplicative_expression ->  . unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (37 38 ) 21
35: [P59 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
36: [P60 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (34 35 36 ) 20
37: [P61 0] unary_expression ->  . postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
38: [P62 0] unary_expression ->  . unary_operator postfix_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP ';' '*' '<' '>' '+' '-' '/' }  0, (46 47 48 49 ) 23
39: [P63 0] postfix_expression ->  . primary_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (50 51 52 53 54 ) 24
40: [P64 0] postfix_expression ->  . IDENTIFIER '(' ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
41: [P65 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 14
42: [P66 0] postfix_expression ->  . postfix_expression '[' expression ']'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
43: [P67 0] postfix_expression ->  . postfix_expression '.' IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
44: [P68 0] postfix_expression ->  . postfix_expression PTR_OP IDENTIFIER   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
45: [P69 0] postfix_expression ->  . postfix_expression INC_OP   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (39 40 41 42 43 44 45 ) 22
46: [P78 0] unary_operator ->  . '-'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 25
47: [P79 0] unary_operator ->  . '!'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 26
48: [P80 0] unary_operator ->  . '&'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 27
49: [P81 0] unary_operator ->  . '*'   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IDENTIFIER '*' '(' }  0, () 15
50: [P24 0] primary_expression ->  . l_expression   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, (15 16 17 18 19 20 ) 12
51: [P25 0] primary_expression ->  . INT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 28
52: [P26 0] primary_expression ->  . FLOAT_CONSTANT   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 29
53: [P27 0] primary_expression ->  . STRING_LITERAL   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 30
54: [P28 0] primary_expression ->  . '(' expression ')'   { AND_OP OR_OP EQ_OP NE_OP GE_OP LE_OP INC_OP PTR_OP '.' ';' '*' '[' '<' '>' '+' '-' '/' }  0, () 16
  0:   On statement to state 170 with (0 )
  1:   On '{' to state 48 with (1 )
  2:   On selection_statement to state 49 with (2 )
  3:   On iteration_statement to state 50 with (3 )
  4:   On assignment_statement to state 51 with (4 )
  5:   On RETURN to state 52 with (5 )
  6:   On IF to state 53 with (6 )
  7:   On WHILE to state 54 with (7 )
  8:   On FOR to state 55 with (8 )
  9:   On ';' to state 56 with (9 )
  10:   On expression to state 57 with (10 )
  11:   On logical_or_expression to state 58 with (11 14 )
  12:   On l_expression to state 59 with (12 16 18 19 50 )
  13:   On logical_and_expression to state 60 with (13 22 )
  14:   On IDENTIFIER to state 61 with (15 40 41 )
  15:   On '*' to state 62 with (17 49 )
  16:   On '(' to state 63 with (20 54 )
  17:   On equality_expression to state 64 with (21 24 25 )
  18:   On relational_expression to state 65 with (23 27 28 29 30 )
  19:   On additive_expression to state 66 with (26 32 33 )
  20:   On multiplicative_expression to state 67 with (31 35 36 )
  21:   On unary_expression to state 68 with (34 )
  22:   On postfix_expression to state 69 with (37 42 43 44 45 )
  23:   On unary_operator to state 70 with (38 )
  24:   On primary_expression to state 71 with (39 )
  25:   On '-' to state 72 with (46 )
  26:   On '!' to state 73 with (47 )
  27:   On '&' to state 74 with (48 )
  28:   On INT_CONSTANT to state 75 with (51 )
  29:   On FLOAT_CONSTANT to state 76 with (52 )
  30:   On STRING_LITERAL to state 77 with (53 )


State 170:
0: [P84 9] iteration_statement -> FOR '(' expression ';' expression ';' expression ')' statement  .   { FLOAT_CONSTANT INT_CONSTANT STRING_LITERAL IF ELSE WHILE FOR RETURN IDENTIFIER '{' '}' ';' '*' '(' '-' '!' '&' }  1, () -1
  Reduce item(s): 0 



